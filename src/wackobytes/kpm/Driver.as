package com.kpm.kpm{	import adobe.utils.ProductManager;		import com.de.polygonal.ds.TreeNode;	import com.kpm.util.*;	import com.kpm.games.*;    import com.kpm.games.game4.*;    import com.kpm.games.walkthewalk.*;    import com.kpm.kpm.Driver;import com.kpm.kpm.DriverData;import com.kpm.ui.*;	import com.nablavector.treemenu.*;    import mx.utils.ObjectUtil;    import flash.utils.getTimer;import flash.display.StageAlign;import flash.display.StageAspectRatio;import flash.display.StageScaleMode;import flash.media.StageWebView;import flash.utils.getDefinitionByName;	import fl.controls.CheckBox;		import flash.desktop.NativeApplication;	import flash.display.Bitmap;	import flash.display.Loader;	import flash.display.MovieClip;	import flash.display.StageDisplayState;	import flash.events.*;	import flash.geom.ColorTransform;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundTransform;	import flash.net.URLRequest;	import flash.system.ApplicationDomain;	import flash.system.Capabilities;	import flash.system.LoaderContext;	import flash.system.System;	import flash.system.fscommand;	import flash.text.Font;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.ui.Keyboard;	import flash.ui.Mouse;	import flash.utils.Timer;	import flash.utils.clearTimeout;	import flash.utils.setTimeout;    import flash.display.Sprite;	/*		com.kpm.kpm.Driver - Document Class for Driver.fla	F Loads booths with games	F keeps track of mute, repeat question, full screen, back, exit	F manage the available bubbles, find successor, predecessor bubbles		com.kpm.kpm.DriverData	V list of initial active bubbles 	F populate bubble requirements	F populate bubbles per game	F populate kids		com.kpm.games.GameData	variables and functions that could be used for other games	V State, GameGoal, Bubble management	V sound instructions, written instructions, Language, SoundPLayer	V Events and sound name constants	F complete bubble, fail bubble, return to driver	  	com.kpm.games.GameDataX 	keeps all gameplay and level variables and constants specific to GameX	V Level management	F set the game theme	F Choose appropriate written feedback depending on State	F update all lvl vars to the appropriate lvl		com.kpm.games.Game1 - Document class for Game1.fla	F keeps all the functionality for the 'Froggy Game"	V bubbles : SpatialSense, IdentifyColor, Numbers_Identifys		com.kpm.games.Game2 - Document class for Game2.fla	F keeps all the functionality for the 'Disassemble Game'	V bubbles : MatchShape, IdentifyColor, IdentifyShape		com.kpm.util.GameComponent	V Scale, Position, Color,	V Movie, which is the graphical representation of the game component	F Drag and drop functionality, Blinking functionality		com.kpm.util.Util	F static methods to manage movieclip resizing, coloring, 	F static methods to manage arrays, get random elements 		com.kpm.util.KpmSound	V contains a single sound and some properties		com.kpm.util.KpmSoundPlayer	F manages a list of sounds to play, enqueueing sounds, 	F fires events after the sound finishes if specified so 		*/				public class Driver extends MovieClip	{		var boothLoader		: Loader = new Loader();		var gameLoader		: Loader = new Loader();		var pictureLoader 	: Loader;			var musicChannel, soundChannel 				: SoundChannel;		var musicSound, languageSound, welcomeSound	: Sound;		var soundLibrary : KpmSoundLibrary;		var driverData			: DriverData;		var boothList			: Array;		var gamesPerPage		: Array;		var currentBoothPage			: int = 0;		var needForMorePages	: Boolean = false;		var languageButtons		: Array;		var currentBooth		: MovieClip;				var currentLanguage		: ELanguage;		var currentTheme		: EGameCharacter;				var currentKid			: Kid;				var currentSuccessors 	: Array;		var activeBubblesPerGame : Array = new Array(5);		var currentBubbleId 	: BubbleId;		var currentBubble 		: KpmBubble;		var currentTreeMenu		: TreeMenu;		var currentBubbleCompleted = false;				var idleCounter			: uint = 0;		var mouseIdle			: MouseIdleMonitor;		var boothClicked		: Boolean = false;		var bubbleFinished		: Boolean = false;        var firstTimeWirelessWarning  : Boolean = false;		var languagePlaying		: Boolean;		var testLoadGameTimer 	: Timer;		var initFilesCounter	: uint;		var teacherFolder 		: KpmIO = new KpmIO();		var returnToDriverTimeout 	: uint ;		var boothImageCounter : uint = 0;		var beingIdle : Boolean = false;		var ui : KpmUI;		public var lastAssemblePuzzle : EPuzzle;		public var previousBubbleId : BubbleId;		public var mute		: Boolean = false;		public var currentGame 		: Object;        public var iOS : Boolean;        public var Android : Boolean;        var currentTreeMenuY:Number;        var currentTreeMenuX:Number;        var teacherMenuDragTimer : Number;        var teacherMenuDragging : Number;        //public var currentGame 		:  Sprite;		var connCounter		: int = 0;				//Sets the stage elements to show the UiDriver		public function Driver()		{            addEventListener(Event.ADDED_TO_STAGE, onInit, false, 0, true);		}        //Initialize files to be used, resolution, loading page.        private function onInit(e:Event):void{            var ytoxRatio =  Capabilities.screenResolutionY/Capabilities.screenResolutionX;            noWireless_Page.visible = false;            Util.debug("Driver.Constructor");            ui = new KpmUI(tWindow_mc, this);            stage.addEventListener (KeyboardEvent.KEY_UP, onKeyReleased, false, 0 , true);            driverData = DriverData.getInstance(this);            Font.registerFont(GroboldFont);            initializeFiles();            setLoadingPage(true);            determineResolution();            tElements.visible = false;            //tKidLoginPage.teacherPage_Bt.visible = tKidLoginPage.tTeacherField.visible = tKidLoginPage.tInstructions.visible = tKidLoginPage.tNextClass_Bt.visible = !DriverData.HOME_VERSION;            tKidLoginPage.tPasswordText.visible = tKidLoginPage.teacherPage_Bt.visible = tKidLoginPage.tTeacherField.visible = tKidLoginPage.tNextClass_Bt.visible = !DriverData.HOME_VERSION;            //tKidLoginPage.tTeacherField.stage.focus = tKidLoginPage.tTeacherField;            tDriver.tWheel.stop();            loaderInfo.uncaughtErrorEvents.addEventListener(UncaughtErrorEvent.UNCAUGHT_ERROR, onUncaughtError, false, 0 , true);            //initailizeTeacherUIEvents();            //DriverData.logTool.addUncaughtErrors(loaderInfo);            addEventListener(Event.ACTIVATE, resizeWindow, false, 0 , true);        }        function determineResolution()        {            iOS = (Capabilities.manufacturer.indexOf("iOS") != -1)            Android = (Capabilities.manufacturer.indexOf("Android") != -1)            if(iOS)            {                tExit_Bt.visible = false                stage.align  = StageAlign.LEFT;            }            if(iOS || Android)            {                stage.scaleMode = StageScaleMode.SHOW_ALL;            }        }        public function resizeWindow(e : Event)        {            var window = NativeApplication.nativeApplication.activeWindow;            UIGod.feedback("");            if(!window) return;            //Windows vars            var osMenuHeight = 28;            var applicationMenuHeight = 22;            if(Capabilities.os.indexOf("Mac OS") == -1)            {//				Util.debug("WINDOWS", this);                osMenuHeight = 32;                applicationMenuHeight = 26;            }            else            {                osMenuHeight = 28;                applicationMenuHeight = 22;            }            window.x = (Capabilities.screenResolutionX - window.width)/2;            window.y = 0;            removeEventListener(Event.ACTIVATE, resizeWindow);        }        //Any error that is not predicted by us is sent to the log reporter.        function onUncaughtError(event : UncaughtErrorEvent)		{			var message : String ;            var type_name:String = ObjectUtil.getClassInfo(event['error']).name;			 if (event.error is Error)             {                 var error:Error = event['error'];                 message = error.toString() + " " + error.getStackTrace();             }             else if (event.error is ErrorEvent)             {                 var error_event:ErrorEvent = event['error'];                 message = "Uncaught ErrorEvent" + " " + type_name + " "  + error_event.type;             }             else             {                 message = event.error.toString() ;             }             			Util.debug("uncaught error " + message);			DriverData.logTool.reportError(message , false);					}				// BEGIN INITIALIZE FILES        //POSET FUNCTION : will initialize new files corresponding to each StaticPoset        // (options could be GeometryPoset, Discapacity Poset, Advanced Poset)		function initializeFiles()		{			DriverData.logTool = new KpmLogTool();			tBubbleMenuWindow.visible = false;			DriverData.debugMode = Capabilities.isDebugger;						Util.debug("is debug mode " + DriverData.debugMode);						//kids to be copied, now visalia			var ClickHereKid : String = "000000100";			var additionalKids : Array = ["000000000", "000000001", "000000002","000000003", "000000004"];						var moreKidsExist : String = "moreKidsExist";			//var moreKidsNumber : String = "1";			var kidsFolderSource : KpmIO = new KpmIO();			kidsFolderSource.setFilePath(DriverData.FOLDER_KIDS, "app");						var kidsFolderDest : KpmIO = new KpmIO();			kidsFolderDest.setFilePath(DriverData.getKidFolder());			var additionalKidSource : Array = new Array();			var additionalKidDest : Array = new Array(); 			var imageBankSource : KpmIO = new KpmIO();			imageBankSource.setFilePath(DriverData.FOLDER_ICONS, "app");			 			var imageBankDest : KpmIO = new KpmIO();			imageBankDest.setFilePath(DriverData.FOLDER_ICONS_DEST, "documents");						var configFileSource : KpmIO = new KpmIO();			configFileSource.setFilePath(DriverData.CONFIG_FILE, "app");			 			var configFileDest : KpmIO = new KpmIO();			configFileDest.setFilePath(DriverData.KpmFolder + DriverData.CONFIG_FILE);			 			var reportsFolderSource : KpmIO = new KpmIO();			reportsFolderSource.setFilePath("data/Reports", "app");						var reportsFolderDest : KpmIO = new KpmIO();			reportsFolderDest.setFilePath("KidsPlayMath/Reports", "documents");						tExit_Bt.addEventListener(MouseEvent.CLICK, onClosingEvent, false, 0 , true);						//teacherFolder.setFilePath(DriverData.getKidFolder("000000100"));			teacherFolder.setFilePath(DriverData.getKidFolder() + DriverData.TEACHER_ID)			DriverData.initFilesNeeded = 0;							//IF the teacher source has not been copied, this is a way of knowing whether its the first time that			// the game is running or not. If it doesnt exist, then copy both the config file and the kids folder            //(which contains the teacher folder)			if(!teacherFolder.exists())			{                Util.debug("teacher foder does not exist");				//ui.CurrentPage = UIConst.KidLoginPage;				KpmIO.copyToAsync(configFileSource, configFileDest, loadUI, loadUI);				KpmIO.copyToAsync(kidsFolderSource, kidsFolderDest, loadUI, loadUI);				DriverData.initFilesNeeded+= 2;			}            //For the Home version we add additional kids            //Need to set the DriverData.HOME_VERSION to true & populate the additionalKids array            //The following code loops the additionalKids folders and copies them to the app folder where they can be accessed easily            Util.debug("Driver.initializeFiles : About to add additional kids");            Util.debug("additionalKids.length" + additionalKids.length);            Util.debug("!teacherFolder.exists()" + !teacherFolder.exists());            if(additionalKids.length > 0 && !teacherFolder.exists())			{				//additionalKidDest.push(new KpmIO());				//additionalKidDest[0].setFilePath(DriverData.KpmFolder + DriverData.FOLDER_KIDS + additionalKids[0]);								Util.debug("Driver.adding additional kids");								for(var i=0; i < additionalKids.length; i++)				{					Util.debug("Driver.adding kid " + additionalKids[i]);										additionalKidSource.push(new KpmIO());					additionalKidSource[i].setFilePath(DriverData.FOLDER_DATA + "additionalKids/" + additionalKids[i], "app");										additionalKidDest.push(new KpmIO());					additionalKidDest[i].setFilePath(DriverData.KpmFolder + DriverData.FOLDER_KIDS + additionalKids[i]);										KpmIO.copyToAsync(additionalKidSource[i], additionalKidDest[i], loadUI, loadUI);					DriverData.initFilesNeeded++;									}			}						//KpmIO.copyInto(moreKidsSource.mFile, kidsFolderDest.mFile, false);			//ToCHECK : else if			if(!reportsFolderDest.exists())			{				KpmIO.copyToAsync(reportsFolderSource, reportsFolderDest, loadUI, loadUI);				DriverData.initFilesNeeded++;			}						else if(DriverData.initFilesNeeded == 0)			{				ui.CurrentPage = UIConst.KidLoginPage;			}            if(!imageBankDest.exists())            {				KpmIO.copyToAsync(imageBankSource, imageBankDest, loadUI, loadUI);                DriverData.initFilesNeeded++;            }        }		public function loadUI(e : Event = null )		{			Util.debug("Driver.loadUi " + e.type);			if(e)				initFilesCounter++;						if(!e || e.type == Event.COMPLETE)			{								//showLoginScreen();								Util.debug("teacher folder ? " + teacherFolder.exists() + initFilesCounter + " " + DriverData.initFilesNeeded);								if(initFilesCounter == DriverData.initFilesNeeded && initFilesCounter !=0)				{					ui.CurrentPage = UIConst.KidLoginPage;					initFilesCounter = 0;				}			}				else			{				DriverData.logTool.reportError ("error could not read files for first copy");			}		}        // END INITIALIZE IO FOR FILES        // UI FUNCTION        public function playTeacher(e : Event)		{			DriverData.allBubblesUnlocked = true;			DriverData.randomBubble = false;			DriverData.log = false;			DriverData.logToFtp = false;			needForMorePages = true;            DriverData.currentGamerId = DriverData.TEACHER_ID            currentLanguage = ELanguage.ENG;            tDriver.tENG.gotoAndPlay("pushed");			setLoadingPage(true);            ui.hideUI();            var loadTimer : Timer = new Timer(500, 1);            loadTimer.addEventListener(TimerEvent.TIMER, loadBoothPage) ;            loadTimer.start();					}				//LOAD BOOTH PAGE (FAIR PAGE)        // UI FUNCTION				public function loadBoothPage(e : Event = null)		{			Util.debug("Driver.loadBoothPage for " + DriverData.currentGamerId, this);			currentBoothPage = 0;			tDriver.tWheel.visible = (currentBoothPage == 0);            Util.debug("loading page " + tLoadingPage);						tElements.visible = true;			tElements.tStats.visible = false;			tDriver.tWheel.play();            UIGod.feedback("");            setLoadingPage(true);			initMouse();			boothList = new Array();						driverData.startProcessingProfile();			this.primaryPoset.addEventListener(Event.COMPLETE, initializeBubblesDone);			this.primaryPoset.addEventListener(DriverData.CYCLE_FOUND, exitApplication);						if (stage.displayState == StageDisplayState.NORMAL)		        stage.displayState=StageDisplayState.FULL_SCREEN_INTERACTIVE;		        		}        //gets called when bubbles and kids are done loading from XML        function initializeBubblesDone(e : Event)        {            this.primaryPoset.removeEventListener(Event.COMPLETE, initializeBubblesDone);            var firstTime : Boolean = false;            Util.debug("initialize Bubbles Done", this);            //TODO:  add kidProfileTags :                //JUST_CREATED -> DATA_LOCAL -> DATA_SAFE                //KID_FRESH = means the kid was just created                //KID_LOCAL = last profile played locally changes have been made since sync                //KID_SAFE = profile has been updated            Util.debug("number of bubbles " + DriverData.currentKidXML.BUBBLE_STATUS.BUBBLE.length());            if(driverData.kidProfileHasBubbles())            {                firstTime = false;                DriverData.currentKidXML.FIRST_TIME = "false";            }            else            {                firstTime = true;            }            currentKid = Kid.makeKidFromXML(DriverData.currentKidXML, true, firstTime);            if(DriverData.allBubblesUnlocked)                currentKid.changeBubbleOutcome(driverData.BubbleIds, EBStatus.Passed, true);            driverData.bubbleStatus = currentKid.BubbleStatus;            initBooths();            initLanguages();            initElements();            //initDriverMusic(true);            addEventListener(ContextMenuEvent.MENU_SELECT, onRightClick, false, 0 , true);            NativeApplication.nativeApplication.addEventListener(Event.EXITING, onClosingEvent, false, 0 , true);            if(GameLib.MUTE_ALL)            {                Mute = true;            }            else            {                //Play welcome sound corresponding to each language.                welcomeSound = Util.createSound(currentLanguage.Text + "_ALL_Instruction_Welcome");                soundChannel = welcomeSound.play();                Mute = false;            }            //2014 : poset!            if(DriverData.kidsBubblesNotInServer)                DriverData.kpmDb.uploadBubbleStatusFirstTime();        }        // INTERACTION MOUSE AND KEYBOARD				function onKeyReleased(e:KeyboardEvent)		{						switch (e.keyCode)			{				case Keyboard.NUMBER_1 :					if(ui.isHidden())						tElements.tStats.visible = !tElements.tStats.visible; break;										case Keyboard.ENTER:					if(ui.CurrentPage == UIConst.KidLoginPage)					{						Util.debug("Driver.onkeyreleased gotoTeacherPage");						ui.goToTeacherPage(null);					}					break;								default : onMouseActive();								break;			}		}		function initMouse()		{			if(DriverData.BIG_CURSOR)			{					CursorManager.init(this.stage);				CursorManager.setCursor(new CursorIdle());			}									if(DriverData.currentGamerId != DriverData.TEACHER_ID)				mouseIdle  = new MouseIdleMonitor(stage, DriverData.MAX_IDLE_TIME_KID);			else				mouseIdle  = new MouseIdleMonitor(stage, DriverData.MAX_IDLE_TIME_TEACHER);							addMouseIdleEvents(true);			mouseIdle.start();		}		public function addMouseIdleEvents (add : Boolean = true)		{						if(!mouseIdle)				return;							if(add)			{								mouseIdle.addEventListener(MouseIdleMonitorEvent.MOUSE_ACTIVE, onMouseActive, false, 0 , true);				mouseIdle.addEventListener(MouseIdleMonitorEvent.MOUSE_IDLE, onMouseIdle, false, 0 , true);			}			else			{				mouseIdle.removeEventListener(MouseIdleMonitorEvent.MOUSE_ACTIVE, onMouseActive);				mouseIdle.removeEventListener(MouseIdleMonitorEvent.MOUSE_IDLE, onMouseIdle);			}		}        function showLog(e : Event)        {            tElements.tStats.visible = !tElements.tStats.visible;        }        function setIdleMouse()		{					}				function onClosingEvent(e : Event)		{			Util.debug("closing event", this);						addMouseIdleEvents(false);            if(DriverData.log)			{				DriverData.logTool.closeSession();				exitApplication();			}			else				exitApplication();		}				  public function reboot():void		  {		    var mgr:ProductManager = 		        new ProductManager("airappinstaller");		    		    mgr.launch("-launch " +			NativeApplication.nativeApplication.applicationID + " " +			NativeApplication.nativeApplication.publisherID);		    		    exitApplication();		  }        function exitApplication(e : Event = null)        {            Util.debug("exiting", this);            try            {                NativeApplication.nativeApplication.exit(0);            }            catch (e : Error) {                Util.debug(e, this);            }        }        // END MOUSE AND KEYBOARD AND CLOSING EVENTS		function uploadingFiles(e : Event)		{			Util.debug("adding event exit application", this);			DriverData.logTool.addEventListener(DriverData.FILES_UPLOADED, exitApplication, false, 0 , true)		}				function onRightClick(e : MouseEvent)		{			//			Util.debug("right click detected", this);			this.dispatchEvent(new MouseEvent(MouseEvent.DOUBLE_CLICK));		}				// BEGIN INITIALIZE BOOTHS        // UI FUNCTIONS		function initBooths()		{			gamesPerPage = [[EGame.G1, EGame.G2, EGame.G3], [EGame.G4]];						initBooth(EGame.G1.Text, new Point2D(120, 460), 1, EGameCharacter.Frog);			initBooth(EGame.G1.Text, new Point2D(370, 550), 3, EGameCharacter.Bee);			initBooth(EGame.G1.Text, new Point2D(600, 470), 2, EGameCharacter.Mouse);			initBooth(EGame.G2.Text, new Point2D(870, 560), 4);			initBooth(EGame.G3.Text, new Point2D(1145, 540), 5);			initBooth(EGame.G4.Text, new Point2D(140, 480), 6, EGameCharacter.Monkey);			initBooth(EGame.G4.Text, new Point2D(390, 520), 7, EGameCharacter.Bird);			populateBoothCbs();					}        function initBooth(pItem : String, pPos : Point2D, pBoothNum : int, pTheme : EGameCharacter = null)		{			Util.debug("init booth number " + pBoothNum);						var tempBooth : MovieClip = Util.createMc("Booth" + ((pBoothNum-1)%5+1));			var themeString : String;			boothLoader = new Loader();						tempBooth.scaleX = tempBooth.scaleY =  0.85;			tempBooth.game = pItem;			tempBooth.gameTheme = pTheme;			tempBooth.page = int((pBoothNum-1)/5);						if(pTheme)				themeString = pTheme.Text;			else				themeString = "";								var request:URLRequest =			new URLRequest(DriverData.FOLDER_IMAGE + tempBooth.game + themeString + ".jpg");						addChild(tempBooth);			boothLoader.load(request);			boothLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, boothImageLoaded);						tempBooth.tImage.buttonMode = true;			tempBooth.tImage.addChild(boothLoader);			tempBooth.tImage.addEventListener(MouseEvent.CLICK, onBoothClick, false, 0 , true);			tempBooth.tBooth.addEventListener(MouseEvent.CLICK, onBoothClick, false, 0 , true);			tempBooth.tBooth.addEventListener(MouseEvent.ROLL_OVER, CursorManager.setOverCursor, false, 0 , true);			tempBooth.tBooth.addEventListener(MouseEvent.ROLL_OUT, CursorManager.setIdleCursor, false, 0 , true);			tempBooth.tImage.addEventListener(MouseEvent.ROLL_OVER, CursorManager.setOverCursor, false, 0 , true);			tempBooth.tImage.addEventListener(MouseEvent.ROLL_OUT, CursorManager.setIdleCursor, false, 0 , true);						tempBooth.tBooth.buttonMode = true;			tempBooth.x = pPos.x;			tempBooth.y = pPos.y;						var my_tf:TextFormat = new TextFormat();			my_tf.size = 18;			my_tf.font = "Calibri";						boothList.push(tempBooth);						if(!DriverData.allBubblesUnlocked )			{				tempBooth.cb_bubble = tempBooth.addChild(new KpmComboBox());				UIGod.setDropdownStyle(tempBooth.cb_bubble, my_tf, 220,35);								with (tempBooth.cb_bubble)				{                    dropdown.rowHeight = 30;                    //dropdown.numEntries = 10;					y = tempBooth.height/2 + 50;					x = -220/2;					addEventListener(MouseEvent.CLICK, CursorManager.bringToFront, false, 0 , true);				}			}		}        function boothImageLoaded( e : Event)        {            Util.debug("booth loaded " + boothImageCounter + " " + DriverData.NUMBER_OF_BOOTHS);            var bm : Bitmap = Bitmap(e.target.loader.content);            bm.smoothing = true;            boothImageCounter++;            if(boothImageCounter + 1 == DriverData.NUMBER_OF_BOOTHS)            {                boothImageCounter = 0;            }        }		function toggleBoothPage(e : Event)		{			//set all elements of the other list of booths visible property to true			//array of games : pages[0] = [G1,G2,G3], pages[1] = G4			currentBoothPage = (currentBoothPage + 1) % 2;			tDriver.tWheel.visible = (currentBoothPage == 0)						populateBoothCbs();		}        //UI FUNCTION        function moreGamesButton()        {            if(currentBoothPage == 0)            {                tElements.tMoreGamesRight_Button.visible = needForMorePages;                tElements.tMoreGamesLeft_Button.visible = false;            }            else            {                tElements.tMoreGamesLeft_Button.visible = true;                tElements.tMoreGamesRight_Button.visible = false;            }        }        // BEGIN BOOTH COMBOBOX FUNCTIONS        // Combobox is a list of passed and active bubbles		function populateBoothCbs()		{			Util.debug("populating menus");            setLoadingPage(false);            for ( var item in boothList)			{				boothList[item].visible = false;				if(!DriverData.allBubblesUnlocked)					populateBoothCb(boothList[item]);				else				{					if(boothList[item].page == currentBoothPage)						boothList[item].visible = true;				}			}						moreGamesButton();								}        //Populate combo box with active and passed bubbles		function populateBoothCb(pBooth : MovieClip)		{			Util.debug("Driver.populateBoothBubbles");			pBooth.visible = false;			pBooth.cb_bubble.visible = !DriverData.HOME_VERSION;			pBooth.cb_bubble.removeAll();			pBooth.cb_bubble.focusEnabled = false;			needForMorePages = false;			var activeBubblesPopulated = false;						var bId : BubbleId;			var active : Boolean;			var bStatus : EBStatus;						if(activeBubblesPerGame[pBooth.game])				activeBubblesPopulated = true;							if(!activeBubblesPopulated)				activeBubblesPerGame[pBooth.game] = new Array();						Util.debug("creating activeBubblesPerGame at " + pBooth.game);						//Populate active bubbles on top			for (var j in this.primaryPoset.BubblesPerGame[pBooth.game])			{				bId  = this.primaryPoset.BubblesPerGame[pBooth.game][j] as BubbleId;				active  = currentKid.BubbleActive[bId.Text] ;                Util.debug("considering " + bId + " to activeBubblesPerGame" + pBooth.game);				if(active && (!PosetManager.ENABLE_POSET_NAVIGATION || Poset.isActive(bId)))				{					Util.debug("bid status " + bId.Text + " " + active, this);					pBooth.cb_bubble.addItem({label:bId.Text + " - Active", data : bId});                    Util.debug("pushing " + bId + " to activeBubblesPerGame" + pBooth.game);					Util.pushToSet(activeBubblesPerGame[pBooth.game], bId);										if(pBooth.page == currentBoothPage)						pBooth.visible = true;															if(pBooth.page > 0 )					{						Util.debug("Setting need for more pages true");						needForMorePages = true;					}				}			}						//Populate other bubbles at bottom			for (var k in driverData.BubblesPerGame[pBooth.game])			{				bId  = driverData.BubblesPerGame[pBooth.game][k] as BubbleId;				bStatus = currentKid.BubbleStatus[bId.Text] ;				active  = currentKid.BubbleActive[bId.Text] ;				//Util.debug("bid status " + bId.Text + " " + bStatus.Text, this);								if(bStatus == EBStatus.Passed && !active)				{					pBooth.cb_bubble.addItem({label:bId.Text + " - Passed", data : bId});				}			}			if(currentBubbleId)			{				Util.debug("making current selected index -1");				pBooth.cb_bubble.selectedIndex = 0;			}		}		//BEGIN UI FUNCTIONS FOR LANGUAGES        function initLanguages()		{			Util.debug("InitLanguages " + DriverData.currentKidXML.GAME_LANGUAGE + " " + currentLanguage);            //Initialize the language of the game to the GAME_LANGUAGE inside the xml representing the kid's profile			if(!currentLanguage)			{				if(DriverData.currentKidXML.GAME_LANGUAGE == "ENG")				{					currentLanguage = ELanguage.ENG;					tDriver.tENG.gotoAndPlay("pushed");				}									else if (DriverData.currentKidXML.GAME_LANGUAGE == "SPA")				{					currentLanguage = ELanguage.SPA;					tDriver.tSPA.gotoAndPlay("pushed");				}								else if (DriverData.currentKidXML.GAME_LANGUAGE == "OBI")				{					currentLanguage = ELanguage.OBI;					tDriver.tOBI.gotoAndPlay("pushed");				}			}            //Safety Check to avoid currentLanguage to be null (this code should not get executed)            if(!currentLanguage)            {                DriverData.logTool.reportError("game language not recognized", false)                currentLanguage = ELanguage.ENG;                tDriver.tENG.gotoAndPlay("pushed");            }            //currentLanguage = ELanguage.ENG;									tDriver.tRandom_Cb.visible = !Util.RELEASE && !DriverData.allBubblesUnlocked;							if(tDriver.tRandom_Cb.visible) {				tDriver.tRandom_Cb.label = "Random";				tDriver.tRandom_Cb.selected = true;			}						languageButtons = new Array();			tDriver.tSPA.lang = ELanguage.SPA;			tDriver.tENG.lang = ELanguage.ENG;			tDriver.tOBI.lang = ELanguage.OBI;			languageButtons.push(tDriver.tSPA);			languageButtons.push(tDriver.tENG);			languageButtons.push(tDriver.tOBI);						for(var item in languageButtons)			{				languageButtons[item].addEventListener(MouseEvent.ROLL_OVER, onRollOverLanguage, false, 0 , true);				languageButtons[item].addEventListener(MouseEvent.CLICK, onLanguageClick, false, 0 , true);				languageButtons[item].buttonMode = true;				languageButtons[item].mouseCursor = true;				languageButtons[item].played = false;			}		}				function onRollOverLanguage(e : Event)		{			languageSound = Util.createSound((e.target).lang.Text);			if (!languagePlaying)			{				languagePlaying = true;				soundChannel = languageSound.play();				soundChannel.addEventListener(Event.SOUND_COMPLETE, onLanguageSoundComplete);			}		}				function onLanguageSoundComplete(e : Event)		{			languagePlaying = false;		}				function onLanguageClick(e : Event)		{			for(var item in languageButtons)				languageButtons[item].gotoAndPlay("normal");							currentLanguage = (e.target).lang;			e.target.gotoAndPlay("pushed"); 		}        //END UI FUNCTIONS FOR LANGUAGES		//BEGIN INIT STAGE ELEMENTS : in Flash, movieclip is tElements        function initElements()		{			var request : URLRequest = 			new URLRequest("file:///" + KpmIO.DEFAULT_LOCATION.nativePath + "/" + DriverData.getKidFolder(DriverData.currentGamerId) + ".jpg");							   			Util.debug("requesting pic " + request.url, this);			//pictureLoader.x = 20;										   	var context:LoaderContext = new LoaderContext(false, ApplicationDomain.currentDomain);		   			   	if(pictureLoader)		   		tElements.tKidPicture.removeChild(pictureLoader);		   						pictureLoader = new Loader();			pictureLoader.load(request, context);			pictureLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, avatarLoaded);									tElements.tKidPicture.addChild(pictureLoader);									tElements.tKidPicture.height = 50;			tElements.tKidPicture.width = 50;			tDriver.tKidGreeting.text = "Welcome to \n KIDS PLAY MATH \n" + currentKid.firstName + "!";								pictureLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, pictureLoaderComplete, false, 0 , true);			tElements.tRepeat_Button.addEventListener(MouseEvent.CLICK, repeatQuestion, false, 0 , true);			tElements.tMute_Button.addEventListener(MouseEvent.CLICK, toggleMute);			tElements.tFullScreen_Button.addEventListener(MouseEvent.CLICK, toggleFullScreen);            tElements.tShowLog_Button.addEventListener(MouseEvent.CLICK, showLog);            tElements.tAccompanied_Button.addEventListener(MouseEvent.CLICK, toggleAccompanied);						tElements.tMoreGamesLeft_Button.addEventListener(MouseEvent.CLICK, toggleBoothPage);			tElements.tMoreGamesRight_Button.addEventListener(MouseEvent.CLICK, toggleBoothPage);			tElements.tWin_Button.addEventListener(MouseEvent.CLICK, ontWinClick);			tElements.tLoose_Button.addEventListener(MouseEvent.CLICK, ontLooseClick);			tElements.tEnjoy_Button.addEventListener(MouseEvent.CLICK, ontEnjoyClick);						tDriver.tRandom_Cb.addEventListener(MouseEvent.CLICK, ontRandomChange);						tBubbleMenuWindow.tExit_Bt.addEventListener(MouseEvent.CLICK, onClosingMenu);						tElements.tTaskTimer.visible = tElements.tTaskCounter.visible = DriverData.SCORE_VISIBLE;						setShortcutButtonsVisible(false);						setChildIndex(tElements, numChildren-1);								tElements.tRepeat_Button.visible = false;			tElements.tRepeat_Button.buttonMode = true;			tElements.tMute_Button.buttonMode = true;			tElements.tFullScreen_Button.buttonMode = true;            tElements.tShowLog_Button.buttonMode = true;            tElements.tAccompanied_Button.buttonMode = true;			tElements.tWin_Button.visible =	tElements.tLoose_Button.visible = tElements.tEnjoy_Button.visible = false;		}				function avatarLoaded ( e : Event)		{			var bm : Bitmap = Bitmap(e.target.loader.content);			bm.smoothing = true;		}				function setShortcutButtonsVisible(pBack : Boolean)		{			tElements.tWin_Button.visible = tElements.tLoose_Button.visible = tElements.tEnjoy_Button.visible = !Util.RELEASE;		}        //UI Function : puts loading page so that user knows the system is currently not responsive.        public function setLoadingPage(pActive : Boolean)        {            tLoadingPage.visible = pActive;            if(pActive)            {                tLoadingPage.gotoAndPlay(1);                addChild(tLoadingPage);            }            else                tLoadingPage.gotoAndStop(1);        }        //UI function. Sets score to a quantity that enjoys the bubble        function ontEnjoyClick(e : Event)        {            CurrentGoal.globalScore  = 0;            onBubbleFinished(null);            returnToBoothPage();        }        //UI function. Sets score to a quantity that passes the bubble        function ontWinClick(e : Event)        {            CurrentGoal.globalScore = 9;            onBubbleFinished(null);            returnToBoothPage();        }        //UI function. Sets score to a quantity that fails the bubble        function ontLooseClick(e : Event)        {            CurrentGoal.globalScore = -9;            onBubbleFinished(null);            returnToBoothPage();        }        //UI Function to change whether or not the bubbles are chosen at random        //when a kid clicks a booth.        function ontRandomChange(e : Event){            DriverData.randomBubble = tDriver.tRandom_Cb.selected;        }        //END INIT STAGE ELEMENTS : in Flash, movieclip is tElements        //UI FUNCTION : user chooses a booth		function onBoothClick(e : MouseEvent)		{						currentBooth  = e.currentTarget.parent as MovieClip;			currentTheme = currentBooth.gameTheme;		   			   	var ct : Object = DriverData.selectedObject;			//if On kid's mode, remember the previous bubble and select the bubble to be played.            //Random refers to the check box on top of the booths			if(!DriverData.allBubblesUnlocked)			{				previousBubbleId = currentBubbleId;								if(DriverData.randomBubble)					currentBubbleId = chooseRandomBubbleId(currentBooth.game);				else					currentBubbleId = currentBooth.cb_bubble.selectedItem.data as BubbleId;								loadIOSBubbleId();							}            //If on Teacher mode,			else			{                //Load the teacher menu for the booth clicked by the user				Util.removeChild(currentTreeMenu);				currentTreeMenu = new TreeMenu(driverData.bubbleTreeMenuXMLs[currentBooth.game]);                tBubbleMenuWindow.addChild(currentTreeMenu);				tBubbleMenuWindow.tGameName.text = EGame[currentBooth.game].Name;				tBubbleMenuWindow.visible = true;				tBubbleMenuWindow.tGameName.text = EGame[currentBooth.game].Name;				setChildIndex(tBubbleMenuWindow, numChildren-1);                tBubbleMenuWindow.tUp.addEventListener(MouseEvent.CLICK, moveMenuUp);                tBubbleMenuWindow.tDown.addEventListener(MouseEvent.CLICK, moveMenuDown);                //Set the position of the menu				currentTreeMenu.x = 250;				currentTreeMenu.y = -15;                addDraggingEvents(true);			}		}        // BEGIN DRAGGING FUNCTIONS FOR TEACHER MENU        function moveMenuUp(e : Event)        {            currentTreeMenu.y += 22;        }        function moveMenuDown(e : Event)        {            currentTreeMenu.y -= 22;        }        function addDraggingEvents(pAdd : Boolean)        {            Util.debug("Driver.addDraggingEvents");            // define lock on y-axis            currentTreeMenuX = currentTreeMenu.x;            teacherMenuDragging = 0;            tBubbleMenuWindow.addEventListener(MouseEvent.MOUSE_MOVE, _mouseMove);            tBubbleMenuWindow.addEventListener(MouseEvent.MOUSE_DOWN, _mouseDown);        }        function _mouseMove(e:MouseEvent):void        {            var distanceMoved : Number = Math.abs(currentTreeMenu.y - currentTreeMenuY);            var timePassed : Number =  getTimer() - teacherMenuDragTimer;            if(teacherMenuDragging == 1)            {                currentTreeMenu.startDrag();                teacherMenuDragging = 2;            }            Util.debug("Driver.mouseMouve");            if(currentTreeMenu.x != currentTreeMenuX) currentTreeMenu.x = currentTreeMenuX;        }        // dragging        function _mouseDown(e:MouseEvent):void        {            teacherMenuDragTimer = getTimer();            teacherMenuDragging = 1;            Util.debug("Driver.mouseDown");            e.target.addEventListener(MouseEvent.MOUSE_UP, _mouseUp);            if(currentTreeMenu.x != currentTreeMenuX) currentTreeMenu.x = currentTreeMenuX;            //if(currentTreeMenu.y != currentTreeMenuY) currentTreeMenu.y = currentTreeMenuY;        }        // dropping        function _mouseUp(e:MouseEvent):void        {            teacherMenuDragging = 0;            currentTreeMenu.stopDrag();            e.target.removeEventListener(MouseEvent.MOUSE_UP, _mouseUp);        }				function onClosingMenu(e : MouseEvent)		{			tBubbleMenuWindow.visible = false;			tBubbleMenuWindow.removeChild(currentTreeMenu);			//currentBooth.transform.colorTransform = new ColorTransform();			currentBooth = null;			currentTheme = null;					}				// Select game and load game		function onMenuSelected(e : TreeMenuEvent)		{			currentBubbleId = this.primaryPoset.BubbleList[e.id].Id;			Util.debug("selecting " + e.id, this);			loadIOSBubbleId();		}        // END DRAGGING FUNCTIONS FOR TEACHER MENU        //BEGIN GAME FUNCTIONS Load bubbleId, Game, theme and language        function loadIOSBubbleId()        {            Util.debug("load IOS bubble id");            if(boothClicked) return;            boothClicked = true;            setLoadingPage(true);            currentBubble = primaryPoset.BubbleList[currentBubbleId.Text];            DriverData.logTool.createBubbleSession(EGame[currentBooth.game], currentBubbleId);//            Util.debug(currentBubbleId + " " + currentLanguage + " " + currentTheme , this);            if(DriverData.TEST_LOAD_GAME)                stressTestLoadGame();            else                loadGameIOS();        }        //to check whether game loads properly even if loaded thousands of times		function stressTestLoadGame(e : Event = null)		{			testLoadGameTimer = new Timer(5000 , 50);			testLoadGameTimer.start();							testLoadGameTimer.addEventListener(TimerEvent.TIMER, loadGameIOS);		}        //Game Function        //loads correct game according to the booth chosen        //1st, 2d, 3d booths -> to G1        //4th booth -> G2        //5th booth -> G3        //6th and 7th booth -> G4        function loadGameIOS(e : Event = null)        {            var gameName : String;            Util.debug("Driver.loadingGameIOS " + currentBooth.game);            switch(currentBooth.game)            {                case "G1" : gameName = "com.kpm.games.Game1";                break;                case "G2" : gameName = "com.kpm.games.Game2";                break;                case "G3" : gameName = "com.kpm.games.walkthewalk.Game3";    break;                case "G4" : gameName = "com.kpm.games.game4.Game4";          break;                default : Util.debug("TypeError: no game?");            }            var GameClass:Class = getDefinitionByName(gameName) as Class;            currentGame =  new GameClass(false) as Sprite;            currentGame.addEventListener(Event.ADDED_TO_STAGE, onGameLoaderCompleteIOS, false, 0, true);            addChild(currentGame as MovieClip);            //Reset mouse interaction, statistics on screen and hide the booth page            mouseIdle.start();            hideBoothPage();            tElements.visible = true;        }        //UI Function that hides the boothe page, used for example before loading a game        public function hideBoothPage(showLogin : Boolean = false)        {            Util.debug("Driver.hideBoothPage ");            tBubbleMenuWindow.visible = false;            tElements.tMoreGamesRight_Button.visible = false;            tElements.tMoreGamesLeft_Button.visible = false;            for ( var item in boothList)                boothList[item].visible = false;            tDriver.tWheel.stop();            if(musicChannel)                musicChannel.stop();            if(soundChannel)                soundChannel.stop();            //UIGod.feedback("memory used " + gameLoader + " " + System.totalMemoryNumber/1024 + " " + gameLoader + " memory free " + System.privateMemory/1024 + " " + System.freeMemory/1024)            //UIGod.feedback("current page " + ui.CurrentPage + " " + UIConst.KidLoginPage)            if(!gameLoader.parent && ui.CurrentPage == UIConst.KidLoginPage && System.privateMemory > 120*1024*1024)                reboot();        }        //onGameLoaderCompleteIOS        //sets framerate, resolution for the game and removes elements not necessary in game page        function onGameLoaderCompleteIOS(e : Event = null)        {            Util.debug("Driver.onGameLoaderComplete IOS")            Util.debug("stage frame rate " + stage.frameRate + " "+  stage + " " + parent.stage + " " + parent.stage.frameRate);            if(currentBooth.game != EGame.G1.Text)            {                stage.frameRate = 12;                parent.stage.frameRate = 12;            }            else            {                stage.frameRate = 18;                parent.stage.frameRate = 18;            }            Util.debug("stage frame rate " + stage.frameRate + " "+  stage + " " + parent.stage + " " + parent.stage.frameRate);            setLoadingPage(false);            tDriver.visible = false;            addChild(tBack_Bt);            tElements.tRepeat_Button.visible = true;            //tElements.tNextLevel.visible = false;            setShortcutButtonsVisible(true);            tExit_Bt.visible = false;            playKpmMusic(false);            Util.debug(currentGame, this);            Util.debug("Game width height " + currentGame.width + " " + currentGame.height);            Util.debug("Game width height " + Capabilities.screenResolutionX + " " + Capabilities.screenResolutionY);             if(currentGame.width < 1280)             {                currentGame.height = 800;                currentGame.width = 1280;             }            if(currentBooth.game == EGame.G3.Text)                currentGame.initGame(currentBubbleId, currentLanguage.Text);            else                currentGame.initGame(currentBubbleId, currentLanguage, currentTheme);            updateBubbleFeedback();            addBubbleEvents(true);            tElements.tBubbleText.text = currentBubbleId.Text;            setChildIndex(tElements, numChildren-1);            if(DriverData.TEST_LOAD_GAME)                returnToDriverTimeout = setTimeout(unloadGame, 800);        }        //UI function : Adds or Removes events that will be fired when bubble is finished.        //onBubbleFinished is entry point for poset management        //returning to Driver gets called after all game interaction is over		function addBubbleEvents(add : Boolean)		{			if(add)			{                currentGame.Data.addEventListener (GameLib.BUBBLE_FINISHED, onBubbleFinished, false, 0 , true);                currentGame.Data.addEventListener (GameLib.RETURN_TO_DRIVER, returningToBoothPage, false, 0 , true);			}			else			{                currentGame.Data.removeEventListener(GameLib.BUBBLE_FINISHED, onBubbleFinished);                currentGame.Data.removeEventListener (GameLib.RETURN_TO_DRIVER, returningToBoothPage);			}					}        //UI Function gets called when each image is done loading		function pictureLoaderComplete(e : Event)		{ 			tElements.tKidPicture.height = 50;			tElements.tKidPicture.width = 50;		}        //Poset function        //This function is called as soon as the bubble's tasks are finished by the kid        //This is an entry function for the Poset Code.		public function onBubbleFinished (e:Event)		{			if(bubbleFinished)				return;			else				bubbleFinished = true;						//addMouseIdleEvents(false);			mouseIdle.stop();						Util.debug("Driver.onBubbleFinished", this);			Util.debug(CurrentGoal.globalScore, this);			Util.debug("score to complete, enjoy " + CurrentScoreToPass + " " + CurrentScoreToEnjoy, this);			Util.debug(currentBubble.neededPassCounter, this);           //compute number of times the bubble has been passed or failed in the past			var numberPass : Number = currentKid.bubbleAttempts[currentBubble.Id.Text].@pass;			var numberFail : Number = currentKid.bubbleAttempts[currentBubble.Id.Text].@fail;									Util.debug("pass " + numberPass);			Util.debug("fail " + numberFail);			Util.debug("needed pass " + currentBubble.neededPassCounter);			Util.debug("needed fail " + currentBubble.neededFailCounter);			            //Comparing score to the score needed to pass. this determines whether the bubble is passed, failed or enjoy            //Some bubbles require to be 'passed' more times in order to really pass the bubble, otherwise we just change            //the status of the bubble to Passed-Active and avoid activating predecessors.			if( CurrentGoal.globalScore  >= CurrentScoreToPass)			{ 				if(numberPass + 1 >= currentBubble.neededPassCounter)					onBubblePassed();				else				{					currentKid.changeBubbleOutcome([currentBubbleId], EBStatus.Passed, true);					currentKid.writeBStatus();										}			}            //same goes for failing			else 			if(CurrentGoal.globalScore <= CurrentScoreToEnjoy)			{				if(numberFail + 1 >= currentBubble.neededFailCounter)					onBubbleFailed();				else 				{					currentKid.changeBubbleOutcome([currentBubbleId], EBStatus.Failed, true);					currentKid.writeBStatus();										}			}            //on enjoy we dont do much except change the status of the bubble to enjoy			else			{				onBubbleEnjoyed();			} 		}				public function get CurrentScoreToPass() : Number		{			Util.debug("Driver.get CurrentScoreToPass " + currentBubble.scoreToComplete);			Util.debug("task factor " + TaskFactor);			return Util.round(currentBubble.scoreToComplete * TaskFactor, GameLib.SCORE_PRECISION);		}				public function get CurrentScoreToEnjoy() : Number		{            Util.debug("Driver.get CurrentScoreToEnjoy : currentBubble" + currentBubble)			return Util.round(currentBubble.scoreToEnjoy * TaskFactor, GameLib.SCORE_PRECISION);		}        //Task factor is a factor that multiplies the score to get the global score		public function get TaskFactor () : Number 		{			var taskFactor : Number;						if(currentBubbleId.Name.ScoreType == EBScoreType.Choice)				taskFactor = Math.sqrt(CurrentGoal.totalTasks);			else				taskFactor = CurrentGoal.totalTasks;							return taskFactor;					}				public function get CurrentGoal () : Goal		{			return currentGame.Data.gameGoal;		}        /*        //Determines whether a bubble's global score is higher than the required        //score to be able to pass the bubble		public function isBubbleComplete() : Boolean		{			Util.debug("is bubble complete", this);			Util.debug(currentBubble.scoreToComplete, this);			Util.debug(CurrentGoal, this);						if(CurrentGoal.globalScore >= CurrentScoreToPass)				return true;			else				return false			}		*/        //Poset Function        //Gets called from onBubbleFinished, when score is not enough to Enjoy		public function onBubblePassed()		{			Util.debug("Driver.onBubblePassed");			tElements.tBubbleSuccess.text = "Pass"			doPassBubble(currentBubbleId);			currentBubbleCompleted = true;            PosetManager.getInstance().updateOutcomesInarow(KpmBubble.PASSED);		}        //Poset function        // Set current bubble to Passed, non-active.        // Set successors of all equivalent bubbles to active		public function doPassBubble(pBubbleId : BubbleId)		{			Util.debug("Driver.doPass bubble " + pBubbleId);						var currentEquivalents : Array = EBName.getEquivalents(pBubbleId);			currentKid.changeBubbleOutcome(currentEquivalents, EBStatus.Passed, false);						for each (var bId in currentEquivalents)				currentKid.changeBubbleOutcome(currentKid.getActiveSuccessors(bId), null, true);						currentSuccessors = currentKid.getActiveSuccessors(pBubbleId);						currentKid.writeBStatus();													}        //Poset Function        //Gets called from onBubbleFinished, when score is not enough to Enjoy		public function onBubbleFailed ()		{			Util.debug("Driver.onBubbleFailed");			tElements.tBubbleSuccess.text = "Fail"						currentBubbleCompleted = false;						if(DriverData.allBubblesUnlocked)				return;						//Util.debug("PEX fail " + currentBubbleId, this);			doFailBubble(currentBubbleId);						currentKid.writeBStatus();						if(currentBubbleId == null)				DriverData.logTool.reportError ("bubble id is null after failing");				}        //Poset function        // Fail a bubble        // Make sure DAG stays consistent		function doFailBubble(pBubbleId : BubbleId)		{			Util.debug("Driver.doFail bubble " + pBubbleId);            //Make sure DAG stays consistent			recomputEBStatus(currentBubbleId);									var bubble : KpmBubble = primaryPoset.BubbleList[pBubbleId.Text];			var currentEquivalents : Array;						//Fail bubble			//if the bubble is initially active and its level is one, dont fail it            //Equivalent bubbles are bubbles that are similar and that are failed (or passed) at the same time            //if any of those equivalents is failed (or passed).			if(!(bubble.initialStatus && pBubbleId.Level == 1))			{				currentEquivalents = EBName.getEquivalents(pBubbleId);				currentKid.changeBubbleOutcome(currentEquivalents, EBStatus.Failed, false);			}							//mark predecessors of the bubble as 'not complete'			currentKid.predecessorsMarked = new Array();						for each (var bId1 in EBName.getEquivalents(pBubbleId))			{				bubble  = primaryPoset.BubbleList[bId1.Text];				Kid.postOrder(bubble.predecessorGraph[PosetManager.CurrentPoset], markPredecessorsNotComplete);			}									//recompute bubble status to check Bubble graph for consistency.			for each (var bId2 in this.primaryPoset.topographicallySortedBubbleList)				if(bId2 != currentBubbleId)					recomputEBStatus(bId2);						//mark not complete bubbles as passed, active			for each (var bId3 in this.primaryPoset.topographicallySortedBubbleList)			{				if(currentKid.BubbleStatus[bId3.Text] == EBStatus.NotComplete)				{					var currentEquivalents1 = EBName.getEquivalents(bId3);					currentKid.changeBubbleOutcome(currentEquivalents1, EBStatus.Passed, true);				}			}		}        //Poset function		//recompute the status for this bubble		function recomputEBStatus(pBId : BubbleId)		{					var bubble : KpmBubble = primaryPoset.BubbleList[pBId.Text];						if(!bubble) Util.debug("bubble not found", this);						Util.debug("Driver.RecomputeStatus for " + pBId + currentKid.BubbleStatus[pBId.Text] + " " + currentKid.BubbleActive[pBId.Text] + " " + bubble.initialStatus);						// if bubble is active and if bubble has predecessors and is not initially active			if(currentKid.BubbleActive[pBId.Text] || currentKid.bubblePassed(pBId.Text))			if(bubble.predecessorGraph[PosetManager.CurrentPoset] != null && bubble.predecessorGraph[PosetManager.CurrentPoset].children != null)			if(!bubble.initialStatus)			{				Util.debug("bubble " + pBId.Text + " has all predecessors complete ?")                //If not all predecessors are complete, deactivate the bubble				if(!currentKid.areChildComplete(primaryPoset.BubbleList[pBId.Text].predecessorList))				{					Util.debug("bubble " + pBId.Text + " does not have predecessors complete")					currentKid.changeBubbleOutcome([pBId], null, false);				} 			}								}        //Poset function        //mark node as not complete, will require some processing later		function markPredecessorsNotComplete(pNode : TreeNode)		{			Util.debug("Driver.markPredecessorsNotComplete");			//Util.debug(pNode.data, this);			if(pNode.data is BubbleId)			{				Util.debug("making " + pNode.data + " as not complete");				currentKid.predecessorsMarked.push(pNode.data);				currentKid.changeBubbleOutcome([pNode.data], EBStatus.NotComplete, false);			}		}	    //Poset Function        //Nothing happens except the status is changed to Enjoy		public function onBubbleEnjoyed()		{			Util.debug("Driver.onBubbleEnjoyed");			tElements.tBubbleSuccess.text = "Enjoy";			//Util.debug("PEX enjoy" + currentBubbleId, this);			currentKid.changeBubbleOutcome([currentBubbleId], EBStatus.Enjoy, true);			currentKid.writeBStatus();			}        //Poset function        //Choose an active standard from a weighted list of active standards for the game provided        //Choose an active bubble from a weighted list of active bubbles        //in the chosen standard        ////////////////////////////////////////////////////////////////////        function chooseRandomBubbleId(pGame : String)        {            Util.debug("Driver.chooseRandomBubbleId for " + pGame);            var bStd : EBStd ;            var stdWeightedArray : Array = new Array();            var currentBoothStandardsSet : Array = new Array();            var activeWeightedBubblesArray : Array = new Array();            Util.debug("active bubbles per game for current game");            for (var i=0; i < activeBubblesPerGame[currentBooth.game].length; i++)            {                Util.debug("i " + i + " " + activeBubblesPerGame[currentBooth.game][i]);            }            Util.debug("currentBoothStandardsSet");            for (var i=0; i < DriverData.standards.length; i++)            {                Util.debug(i + " " + DriverData.standards[i].Weight)            }            //make a weighted list of all active standards            for (var i=0; i < activeBubblesPerGame[currentBooth.game].length; i++)            {                Util.debug("about to push to set " + activeBubblesPerGame[currentBooth.game][i].Name.Standard);                Util.debug("currentbooth.game " + currentBooth.game);                Util.debug("active bubbles at i " + activeBubblesPerGame[currentBooth.game][i].Name);                Util.printArray(activeBubblesPerGame[currentBooth.game]);                if(activeStandard(activeBubblesPerGame[currentBooth.game][i].Name.Standard, activeBubblesPerGame[currentBooth.game]))                {                    if(Util.pushToSet(currentBoothStandardsSet, activeBubblesPerGame[currentBooth.game][i].Name.Standard))                    {                        Util.debug("the standard has not being push to the set yet, the standard is appearantly active");                        Util.debug(currentBoothStandardsSet.length-1 + " " + currentBoothStandardsSet[currentBoothStandardsSet.length-1] + " " + currentBoothStandardsSet[currentBoothStandardsSet.length-1].Weight);                        for(var j=0; j < currentBoothStandardsSet[currentBoothStandardsSet.length-1].Weight; j++)                        {                            Util.pushToArray(stdWeightedArray, activeBubblesPerGame[currentBooth.game][i].Name.Standard);                        }                    }                }            }            bStd = Util.getRandomFrom(stdWeightedArray) as EBStd;            Util.debug("WEIGHTED ACTIVE STANDARD LIST : ");            for (var i=0; i < stdWeightedArray.length; i++)                Util.debug(stdWeightedArray[i].Text);            //Util.debug("choosing a random BubbleGroup for Standard :           " + bStd.Text + "");            //make a weighted list of all active bubbles in the chosen standards            Util.debug("pexi " + bStd.Index);            for each (var bName : EBName in this.primaryPoset.BubbleNamesPerStd[bStd.Index])            {                Util.debug("pex " + bStd.Index);                for (var h = 1; h <= bName.MaxLevel; h++)                {                    var bId : BubbleId = new BubbleId(bName, h);                    Util.debug("trying " + bId);                    Util.debug(currentKid.BubbleActive[bId.Text] + " " + this.primaryPoset.BubbleList[bId.Text] + " " + this.primaryPoset.BubbleList[bId.Text].games[currentBooth.game])                    //if bubble exists, and its active, and the game supports it,                    if (currentKid.BubbleActive[bId.Text] == true)                        Util.debug("pex " + bStd.Index + " " + bId.Text);                        if(primaryPoset.BubbleList[bId.Text])                            if(primaryPoset.BubbleList[bId.Text].games[currentBooth.game])                            {                                //Util.debug("weight for" + bId.Text + " " + driverData.BubbleDef[bId.Text].weight, this);                                for(var l=0; l < primaryPoset.BubbleList[bId.Text].weight; l++)                                {                                    //Util.debug("");                                    Util.debug("pushing " + bId + " to active Weighted BubblesArray");                                    activeWeightedBubblesArray.push(bId);                                }                            }                }            }            //if the list of active weighted bubbles is not empty, then select a bubble at random            if(activeWeightedBubblesArray.length > 0)            {                var bId : BubbleId = Util.getRandomFrom(activeWeightedBubblesArray) as BubbleId;                Util.debug("       WEIGHTED ACTIVE BUBBLE LIST  : ");                for (var i=0; i < activeWeightedBubblesArray.length; i++)                {//					Util.debug(activeWeightedBubblesArray[i].Text);                }                if(previousBubbleId && previousBubbleId.equals(bId))                    Util.debug("same bubble as previous" + bId + " " + previousBubbleId);                return bId;            }            else            {                throw new Error("choosing a random bubble from an empty list!");            }        }        //Determines whether a standard is active or not        function activeStandard(bStd : EBStd, bBubbles : Array) : Boolean        {            Util.debug("Driver.activeStandard");            Util.printArray(bBubbles);            for (var i = 0; i < bBubbles.length; i++)            {                Util.debug("comparing to identify active bubbles in standard :");                Util.debug(bStd.Text);                Util.debug(bBubbles[i].Name.Standard.Text);                if(bStd.equals(bBubbles[i].Name.Standard))                {                    Util.debug(bStd + " " + bBubbles[i].Name.Standard);                    return true;                }            }            Util.debug("activeStandard false");            return false;        }        // BEGIN RETURN TO BOOTH PAGE UI Function        // Sets a delay so that when the game finishes, the change to a new page is not so abrupt and		public function returningToBoothPage(e : Event)		{			//Util.debug("Driver.returningToDriver", this);			if(e != null)				returnToDriverTimeout = setTimeout(returnToBoothPage, 2200);			else				returnToBoothPage();					}		//UI Function        //Returns from the end of the game to the fair page		public function returnToBoothPage()		{            Util.debug("Driver.returnToDriver " + currentGame);			clearTimeout(returnToDriverTimeout);						if(!currentGame)				return;            DriverData.logTool.closeBubbleSession(currentKid.BubbleAttempts, currentBubbleId);            if(DriverData.logToFtp)                DriverData.logTool.uploadBB();            //addMouseIdleEvents(true);			bubbleFinished = false;			mouseIdle.start();			updateBubbleFeedback();									if(currentBubbleCompleted)			{				if(currentSuccessors && currentSuccessors.length != 0)					currentBubbleId = Util.getRandomFrom(currentSuccessors) as BubbleId;			}												unloadGame();															if(!DriverData.bubbleProgression || !Util.searchInArray(driverData.BubblesPerGame[currentBooth.game], currentBubbleId))			{				reloadBoothPage();				populateBoothCbs();							}		}        // END RETURN TO BOOTH PAGE UI Function    //Cleaning function    //Called after game is over    function unloadGame (e:Event = null)    {        clearTimeout(returnToDriverTimeout);        tDriver.visible = true;        if(currentGame)        {            if(currentGame is Game)            {                if(currentGame.onAnimationProgress)                    currentGame.removeEventListener(Event.ENTER_FRAME, currentGame.onAnimationProgress);            }            addBubbleEvents(false);            if(currentGame.Data.updateLevelTimer)                currentGame.Data.updateLevelTimer.removeEventListener(TimerEvent.TIMER, currentGame.Data.returnToDriver);            if(currentGame.Data.taskTimer)                currentGame.Data.taskTimer.removeEventListener(TimerEvent.TIMER, updateTaskTimer);            //currentBooth.transform.colorTransform = new ColorTransform();            //gameLoader.unloadAndStop();            //gameLoader.unload();            //removeChild(gameLoader);            removeChild(currentGame as Sprite);            System.gc();            System.gc();            currentGame = null;            stage.frameRate = 25;        }    }        function reloadBoothPage()        {            boothClicked = false;            tDriver.tWheel.play();            Util.debug("playing wheel", this);            setShortcutButtonsVisible(false);            if(Capabilities.manufacturer.indexOf("iOS") == -1)                tExit_Bt.visible = true;            tElements.tRepeat_Button.visible = false;            playKpmMusic(!mute);            //currentBooth.transform.colorTransform = new ColorTransform();            for(var item in languageButtons)                languageButtons[item].played = false;            //welcomeSound = Util.createSound("WelcomeBack"+Util.getRandomNumberBetween(1,2));            //welcomeChannel = welcomeSound.play();        }				public function playKpmMusic (pPlay : Boolean)		{            Util.debug("Driver.playKpmMusic " + pPlay)			if(pPlay)			{				tElements.tMute_Button.gotoAndPlay("on");				musicSound = new DriverMusicSound();				musicChannel = musicSound.play(	0, 10, new SoundTransform(0.5));							}			else			{				tElements.tMute_Button.gotoAndPlay("off");				if(musicChannel)					musicChannel.stop();				if(soundChannel)					soundChannel.stop();							}		}						//Returns a list of all bubbles that have already been passed by the current kid        //MOVE to Kid.as		public function getCompleteBubbles() : Array		{			var completeArray = new Array();						for (var item in currentKid.BubbleStatus)				if(currentKid.BubbleStatus[item] == EBStatus.Passed)					completeArray.push(item);								return completeArray;		}				public function toggleMute(e:Event)		{				Mute = !mute;		}				public function set Mute(pMute : Boolean)		{						mute = pMute;						Util.debug("setting mute to " + mute, this);						if(mute)				tElements.tMute_Button.gotoAndPlay("off");			else 				tElements.tMute_Button.gotoAndPlay("on");								if(currentGame)			{				if(currentGame is Game)					currentGame.Data.mute();				else 					currentGame.mute(mute);					}			else			{				playKpmMusic(!mute);			}		}				public function repeatQuestion(e: Event)		{			if(currentGame)				currentGame.repeatQuestion();		}				public function toggleFullScreen(e:Event)		{			UIGod.feedback("");			Util.debug("toggle fullscreen " + stage.displayState, this);		    if (stage.displayState == StageDisplayState.NORMAL) 		        stage.displayState=StageDisplayState.FULL_SCREEN_INTERACTIVE;		    else		        stage.displayState=StageDisplayState.NORMAL;		}        public function notifyInternet(pInternetAvailable : Boolean)        {            Util.debug("Driver.notifyInternet" + pInternetAvailable);            if(!pInternetAvailable && !firstTimeWirelessWarning)            {                noWireless_Page.visible = true;                setChildIndex(noWireless_Page, numChildren-1)                firstTimeWirelessWarning = true;            }        }        public function toggleAccompanied(e:Event)		{				Util.debug("toggle DriverData.accompanied " , this);		    Accompanied = !DriverData.accompanied;		}        public function get CurrentData() : GameLib        {            if(currentGame)		return currentGame.Data;            else				return null;        }        public function get CurrentBubble() : KpmBubble { return currentBubble; }        function onMouseActive(e : MouseIdleMonitorEvent = null)        {            //Util.debug("idle counter mouse active " + idleCounter);            if(currentGame)            {                idleCounter = 0;            }        }        public function addToLog(pXml : XML)        {            DriverData.logTool.addToLog(pXml);        }        public function get Accompanied() : Boolean { return DriverData.accompanied; }				public function set Accompanied(pAccompanied)		{			if(DriverData.accompanied && !pAccompanied)			{				returnToBoothPage();			}			DriverData.accompanied = pAccompanied;			//DriverData.log = !DriverData.accompanied			DriverData.logToFtp = !DriverData.accompanied;			if(DriverData.accompanied)				tElements.tAccompanied_Button.gotoAndPlay("on");			else				tElements.tAccompanied_Button.gotoAndPlay("off");							}				public function updateBubbleFeedback()		{			Util.debug("updating bubble feedback" + currentBubbleId, this);						var xmlLogString : String ;						if(currentBubbleId)				tElements.tBubbleText.text = currentBubbleId.Text;						else				tElements.tBubbleText.text = "";							var statsString : String = "";  			var separator : String = " - ";						statsString += "Score : " + (CurrentGoal.globalScore) + separator;			statsString += "TaskScore : " + (CurrentGoal.taskScore) + separator;			statsString += "Threshold : " + CurrentScoreToEnjoy + " / " + CurrentScoreToPass + separator;						if(currentBubbleId.Name.ScoreType == EBScoreType.Choice)			{				statsString += "m/n	: " + CurrentGoal.numCorrectOptions + " / " + CurrentGoal.numOptions + separator;					}				else				statsString += "opt/clicks/dfromTarget	: " + CurrentGoal.lengthOptimalPath + " / " + CurrentGoal.lengthPath + " / " + CurrentGoal.distanceFromTarget + separator;						statsString += "Score Type : " + currentBubbleId.Name.ScoreType.Text + " FPS : " + stage.frameRate;						tElements.tTaskCounter.text = " Tasks: " + CurrentGoal.succededTaskCounter + " / " + CurrentGoal.taskCounter + " / " + CurrentGoal.totalTasks + " . ";            Util.debug(" Tasks: " + CurrentGoal.succededTaskCounter + " / " + CurrentGoal.taskCounter + " / " + CurrentGoal.totalTasks + " . ");			tElements.tTaskStats.text = statsString;									//xmlLogString = currentGame.Data.taskXML.toXMLString();						if(DriverData.allBubblesUnlocked)				return; 							xmlLogString = DriverData.logTool.BubbleSessionXML.toXMLString()			xmlLogString = xmlLogString.split("=").join(":");			xmlLogString = xmlLogString.split("\"").join(" ");			tElements.tStats.tLog.text = xmlLogString;		}				public function resetBubbleFeedback()		{			if(DriverData.HOME_VERSION && tElements.tBubbleSuccess.visible)			{				//tElements.tBubbleText.text = "";				tElements.tTaskCounter.visible = false;				tElements.tStats.tLog.visible = false;				tElements.tTaskStats.visible = false;				tElements.tTaskTimer.visible = false;				tElements.tBubbleSuccess.visible = false;			}								tElements.tBubbleText.text = "";			tElements.tTaskCounter.text = "";			tElements.tStats.tLog.text = "";			tElements.tTaskStats.text = "";			tElements.tTaskTimer.text = "";			tElements.tBubbleSuccess.text = ""		}		public function updateTaskTimer(e: Event)		{			tElements.tTaskTimer.text = String(currentGame.Data.taskTimerNumber());		}				//This function executes when the idle time is over (defined in DriverData, for teachers and for kids)		//the first time repeat the question, the second time go back to the fair		function onMouseIdle(e : MouseIdleMonitorEvent)		{			//Util.debug("idle counter mouse idle" + mouseIdle.idleTime);			//stage.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_MOVE));			beingIdle = true;						//if a game is playing, then repeat the question			if(mouseIdle.idleTime < 2*DriverData.MAX_IDLE_TIME_KID && DriverData.currentGamerId != DriverData.TEACHER_ID)			{				if(currentGame)				{					currentGame.repeatQuestion();				} 			}			else if(mouseIdle.idleTime >= 2*DriverData.MAX_IDLE_TIME_KID || DriverData.currentGamerId == DriverData.TEACHER_ID)				 if(ui.isHidden() || ui.CurrentPage == UIConst.KidLoginPage)					ui.goBack(null);						//Util.debug("idle counter mouse idle" + idleCounter);					}        public function get primaryPoset () : Object {            if(PosetManager.ENABLE_POSET_NAVIGATION)                return PosetManager.getInstance().posetList[Poset.PRIMARY];            return DriverData.getInstance();        }	}}