package com.kpm.kpm {		import com.de.polygonal.ds.DListIterator;	import com.de.polygonal.ds.TreeNode;	import com.kpm.util.ELanguage;	import com.kpm.util.Util;import com.kpm.kpm.KpmBubble;import flash.utils.describeType;       public class Kid    {        public static const PROFILE_VERSION : uint = 1;    	var id   	       	: String         //randomly generated 6 digit number when kid is created        var firstName      	: String;        var lastName  		: String;        var age            	: uint;        var primaryLanguage : ELanguage;        var gameLanguage	: ELanguage;        var firstTime 		: Boolean ;                //list of bubbles completed successfully, or unsuccessfully        var bubbleStatus 	: Array;        var achievements 	: Array;        var bubbleActive 	: Array;         var bubbleAttempts	: Array;		//var bubblesWeight : Array;        var predecessorsMarked : Array;        var kidXML : XML;        var reports : Array;                                public function Kid(pId : String, pFirstName : String, pLastName : String, pAge : uint,         					pPrimaryLanguage : ELanguage = null, pGameLanguage : ELanguage = null,        					pFirstTime : Boolean = false )    	{    		id = pId;    		firstName = pFirstName;    		lastName = pLastName;    		age = pAge;	    		//kidClass = pClass;    		    		if(!pPrimaryLanguage) 	primaryLanguage = ELanguage.ENG;    		else				  				primaryLanguage = pPrimaryLanguage;    		    		if(!pGameLanguage) 		gameLanguage = ELanguage.ENG;    		else				  	gameLanguage = pGameLanguage;    		    		firstTime = pFirstTime;    		    		bubbleStatus = new Array(DriverData.MAX_NUM_BUBBLES);    		bubbleActive = new Array(DriverData.MAX_NUM_BUBBLES);    		bubbleAttempts = new Array(DriverData.MAX_NUM_BUBBLES);    		    		    		    	}        //MakeKidFromXML    	public static function makeKidFromXML(pXMLKid : XML, pCheckProfileVersion : Boolean = true, pInitialStatus : Boolean = false) : Kid		{			Util.debug("Kid.makingKidFromXML ");            Util.debug("initial status " + pInitialStatus);						var pId 			: String;			var pFirstName 		: String;			var pLastName 		: String;			var pHeadStartSite 	: String;			var pAge 			: uint;			var pPrimaryLang	: ELanguage;			var pGameLang		: ELanguage;			var pFirstTime		: Boolean;			//var pClass			: int;			var newKid 			: Kid;			var passBubblesUntil : int;									if(!pXMLKid)				DriverData.logTool.reportError("creating kid, xml is null");            //Get all the nodes from the XML and create a Kid object			pId = pXMLKid.UID;			pFirstName = pXMLKid.FIRST_NAME;			pLastName = pXMLKid.LAST_NAME;			pAge = Number(pXMLKid.AGE);			pHeadStartSite = pXMLKid.LOCATION;			pPrimaryLang = ELanguage[pXMLKid.PRIMARY_LANG];			pGameLang = ELanguage[pXMLKid.GAME_LANG];			pFirstTime = pXMLKid.FIRST_TIME;			newKid = new Kid(pId, pFirstName, pLastName, pAge, pPrimaryLang, pGameLang, pFirstTime);			newKid.kidXML = pXMLKid;						for each (var bId : BubbleId in DriverData.getInstance().BubbleIds)			{				newKid.bubbleActive[bId.Text] = false;				newKid.bubbleStatus[bId.Text] = EBStatus.NotPlayed;				newKid.bubbleAttempts[bId.Text] = new XML(<Counters></Counters>);			}			//If kid hasnt played any bubbles			if(pInitialStatus)			{                //Erase any bubbles that were there				if("BUBBLE_STATUS" in newKid.kidXML)					delete newKid.kidXML.BUBBLE_STATUS;                //Initialize all bubbles				Util.debug("will loop to set initial state");				//for each (var bubble : KpmBubble in DriverData.getInstance().FullPosetBubbleList)                Util.printArray(DriverData.Driver.primaryPoset.BubbleList);                for each (var bubble : KpmBubble in DriverData.Driver.primaryPoset.BubbleList)				{					newKid.bubbleAttempts[bId.Text] = new XML(<Counters pass="0" fail="0" enjoy="0"/>);									if(bubble.Id.Level == 1)					    if(bubble.initialStatus)                            newKid.changeBubbleOutcome([new BubbleId(bubble.Id.Name, bubble.Id.Name.MinLevel)], EBStatus.NotPlayed, true, false, false);					if(newKid.bubbleStatus[bubble.Id.Text] == EBStatus.Passed)						for each (var bId2 in EBName.getEquivalents(bubble.Id))							newKid.changeBubbleOutcome(newKid.getActiveSuccessors(bId2), EBStatus.NotPlayed, true, false, false);										Util.debug("initial state for " + bubble.Id + " " + bubble.Id.Name.MinLevel + " " + newKid.bubbleStatus[bubble.Id.Text] + " " + newKid.bubbleActive[bubble.Id.Text]);										}                //CheckProfileVersion to add any new bubbles that were implemented				if(pCheckProfileVersion)				    newKid = checkKidProfileVersion(newKid);			}			else			{                //CheckProfileVersion to add any new bubbles that were implemented				if(pCheckProfileVersion)				newKid = checkKidProfileVersion(newKid);								for each (var xmlBubble : XML in pXMLKid.BUBBLE_STATUS.*)				{					newKid.bubbleStatus[xmlBubble.BUBBLE_ID] = EBStatus[xmlBubble.STATUS];										if(xmlBubble.ACTIVE == "true")						newKid.bubbleActive[xmlBubble.BUBBLE_ID] = true;					else						newKid.bubbleActive[xmlBubble.BUBBLE_ID] = false;											newKid.bubbleAttempts[xmlBubble.BUBBLE_ID] = xmlBubble.Counters;				}			}			return newKid;					}				static function checkKidProfileVersion(pNewKid : Kid)		{			Util.debug("Kid.checkKidProfileVersion");									//Inventory of additional bubbles since version 1.0						var newbubbles = new Array();			newbubbles[0] = <BUBBLE><BUBBLE_ID>CompareEstimate_3_1</BUBBLE_ID><STATUS>NotPlayed</STATUS><ACTIVE>true</ACTIVE></BUBBLE>;			newbubbles[1] = <BUBBLE><BUBBLE_ID>ChangePlus1_3_1</BUBBLE_ID><STATUS>NotPlayed</STATUS><ACTIVE>true</ACTIVE></BUBBLE>;						var requisits : Array = new Array();			requisits[0] = null;			requisits[1] = "CountNumeral_5_1";						//IF the profile has not been versioned yet,									var index : int = 0;								if(!("PROFILE_VERSION" in pNewKid.kidXML) || pNewKid.kidXML.PROFILE_VERSION == null || pNewKid.kidXML.PROFILE_VERSION+"" == "")					index = 0;				else 					index = pNewKid.kidXML.PROFILE_VERSION;													for(var i = 0 ; index <= Kid.PROFILE_VERSION; index++)				{					Util.debug("index " + index );					Util.debug(" checking requisit " + requisits[index] );					Util.debug("bubble in profile " + Kid.findBubble(pNewKid, requisits[index], EBStatus.Passed));					if(requisits[index] == null || Kid.findBubble(pNewKid, requisits[index], EBStatus.Passed)) 					if(!Kid.findBubble(pNewKid, newbubbles[index].BUBBLE_ID))					{						Util.debug("adding additional bubbles ");						Util.debug(newbubbles[index]);						pNewKid.kidXML.BUBBLE_STATUS.appendChild(newbubbles[index]);						//DriverData.getInstance().kidFile.write(pNewKid.kidXML);					}					else					{						Util.debug("new bubble already here");					}				}						pNewKid.kidXML.PROFILE_VERSION = Kid.PROFILE_VERSION;			DriverData.getInstance().kidFile.write(pNewKid.kidXML);						Util.debug("currentKidXML.profileVersion " + pNewKid.kidXML.PROFILE_VERSION) ;						return pNewKid;					}		public static function findBubble(pKid :Kid, pBId : String, pStatus : EBStatus = null) : Boolean		{			Util.debug("Kid.findBubble " + pBId);			Util.debug(pStatus);						if(pStatus)				Util.debug("status not null " + pStatus.Text);						for each (var bubble : XML in pKid.kidXML.BUBBLE_STATUS.children())			{				Util.debug(bubble.BUBBLE_ID + " " + pBId)				if(bubble.BUBBLE_ID ==  pBId)				{					Util.debug("match");					Util.debug(bubble.STATUS + " " + pStatus);										if(pStatus == null || (pStatus.Text == bubble.STATUS))					{						return true;					}				}			}			return false;											}		        //This function changes the EBSTatus of a list of bubbles, as well as their status (		public function changeBubbleOutcome( pBIdArray : Array, pLastOutcome : EBStatus = null, pStatus : Boolean = false, pForceWriteXML : Boolean = false, pWriteToProfile : Boolean = true)		{			Util.printArray(pBIdArray);			Util.debug("Kid.changeBubbleOutcome to " + pLastOutcome);			Util.debug("will set  bubble to active " + pStatus);						var bId : BubbleId;			var status : Boolean;  			var appendXML : XML;							//if no parameters assume you are activating bubble						if(!("BUBBLE_STATUS" in kidXML))				kidXML.appendChild(<BUBBLE_STATUS></BUBBLE_STATUS>);									for(var item in pBIdArray)            {            	            	bId = pBIdArray[item];            									if(pLastOutcome == EBStatus.Enjoy) 					status = bubbleActive[bId.Text];				else					status = pStatus;									setStatus(bId, status);				setOutcome(bId, pLastOutcome, pWriteToProfile);                				var loopBubbleXML : XML;				var bubbleExists : Boolean = false;								if(!pForceWriteXML && !DriverData.accompanied)				{					Util.debug("will write existing bubble to xml");					for each (var bubble : XML in kidXML.BUBBLE_STATUS.children())					{						if(bubble.BUBBLE_ID ==  bId.Text)						{							Util.debug("bubble exists!");							bubble.STATUS = bubbleStatus[bId.Text].Text;							bubble.Counters = bubbleAttempts[bId.Text];							bubble.ACTIVE = status;							//Util.debug("writing bubble status to XML " + bubble.STATUS + " " +  bubble.ACTIVE + " " + bubble.BUBBLE_ID, this);							bubbleExists = true;							break;						}					}				}   								if((!bubbleExists || pForceWriteXML) && !DriverData.accompanied)				{					var bubbleXML : XML = 					<BUBBLE>					<BUBBLE_ID>{bId.Text}</BUBBLE_ID>					<STATUS>{bubbleStatus[bId.Text].Text}</STATUS>					<ACTIVE>{status}</ACTIVE>					</BUBBLE>;										bubbleXML.appendChild(bubbleAttempts[bId.Text]);										kidXML.BUBBLE_STATUS.appendChild(bubbleXML);					Util.debug("writing new bubble to XML " + bId.Text, this);				}								var driverData : DriverData = DriverData.getInstance();            }            kidXML.SYNC_LOCAL_DATE = Util.getSecondsFrom1970();		}				public function setStatus(pBubbleId : BubbleId, pStatus : Boolean)		{			Util.debug("Kid.setStatus" + pBubbleId + " active " + pStatus); 			//Util.debug("bubble group corresponding to " + pBubbleId);			//Util.debug(bubbleGroup.toXMLString());						bubbleActive[pBubbleId.Text] = pStatus;		}						public function setOutcome(pBubbleId : BubbleId, pLastOutcome : EBStatus, pWriteToProfile : Boolean = true)		{			if(!pLastOutcome)			{				DriverData.logTool.addBubbleChanged(pBubbleId, bubbleActive[pBubbleId.Text], pLastOutcome);				return;			}									Util.debug("Kid.setOutcome " + pBubbleId + " " + pLastOutcome); 			//Util.debug("bubble group corresponding to " + pBubbleId);			//Util.debug(bubbleGroup.toXMLString());						var oldOutcome : EBStatus = bubbleStatus[pBubbleId.Text];			bubbleStatus[pBubbleId.Text] = pLastOutcome;						if(pWriteToProfile)			{					if(oldOutcome != EBStatus.NotComplete)				{								    if(pLastOutcome == EBStatus.Enjoy)	            	{	            		bubbleAttempts[pBubbleId.Text].@enjoy++;	            		//bubbleAttempts[pBubbleId.Text].@history+= "enjoy-";	            	}	            	if(pLastOutcome == EBStatus.Failed)	            	{	            		bubbleAttempts[pBubbleId.Text].@fail++;	            		//bubbleAttempts[pBubbleId.Text].@history+= "fail-";	            	}	            	if(pLastOutcome == EBStatus.Passed)	            	{	            		bubbleAttempts[pBubbleId.Text].@pass++;	            		//bubbleAttempts[pBubbleId.Text].@history+= "pass-";	            	}	   			}	  		}   			   			if(pLastOutcome != EBStatus.NotComplete)				DriverData.logTool.addBubbleChanged(pBubbleId, bubbleActive[pBubbleId.Text], pLastOutcome);		}				function eraseInactiveBubbles()		{			for each (var bubble : XML in kidXML.BUBBLE_STATUS.children())			{								if(bubble.ACTIVE == "false")				{					Util.debug("erasing " + bubble.BUBBLE_ID, this);					delete kidXML.BUBBLE_STATUS.bubble;				}			}						}        //Writes the XML object that gets updated to the kid's profile file        public function writeBStatus()        {            Util.debug("will writeing bubble status to file");            DriverData.getInstance().kidFile.write(kidXML);        }        //determines wether a bubble is passed        public function bubblePassed(index : String, pNoRedo : Boolean = false)		{			return (BubbleStatus[index] == EBStatus.Passed);		}        //Poset Function        // Change so that it accepts multiple posets !        // Get all successors bubbles from the paramter bubble's successorList        public function getActiveSuccessors(pBubbleId : BubbleId) : Array		{			Util.debug("Kid.getSuccessors " + pBubbleId);			var bubble : KpmBubble = DriverData.getInstance().BubbleList[pBubbleId.Text];			var successors : Array = new Array();            //if a bubble does not have any sucessors, return empty array			if(!bubble || !bubble.successorList[PosetManager.CurrentPoset])				return successors;            //if bubble does have successors, then loop each one of them            //  if a successor is active, add it to the successors List to be returned			if(bubble.successorList[PosetManager.CurrentPoset].length == 0)				Util.debug("activate successors : no successors", this);				 			for (var i in bubble.successorList[PosetManager.CurrentPoset])			{				var bId : BubbleId = bubble.successorList[PosetManager.CurrentPoset][i];				if (computeActive(bId))				{					Util.debug("setting sucessor " + bId + " to active", this);					successors.push(bId);				}			}						Util.debug("here are the successors found", this);			Util.printArray(successors);            return successors;		}        //Poset Function        // Computes if a bubble is active or not        public function computeActive(pBubbleId : BubbleId) : Boolean		{			Util.debug("Kid.isActive " + pBubbleId);			var bubble : KpmBubble = DriverData.getInstance().BubbleList[pBubbleId.Text];			if(BubbleStatus[pBubbleId.Text] == EBStatus.Passed)				return false;						if(!bubble) Util.debug("bubble not found", this);						//If there is no predecessors, then the bubble must be active because it belongs to the initially activated bubbles            if(bubble.predecessorGraph[PosetManager.CurrentPoset] == null)				return true;							if(bubble.predecessorGraph[PosetManager.CurrentPoset].children == null)				return true;            //Check if the predecessorList nodes are complete            //if we are ath this point the bubble does have non-null predecessors.			var areChildrenComplete : Boolean = areChildComplete(bubble.predecessorGraph[PosetManager.CurrentPoset]);			return areChildrenComplete;	 					}					//Poset Function        // Check if the children of a particular node (or bubble) are complete		public function areChildComplete(pNode : TreeNode) : Boolean		{						Util.debug("will check if the children of " + pNode.data + " are complete");			var child: DListIterator = pNode.children.getIterator() as DListIterator;									var complete; 						if(pNode.data == "OR")				complete = false;			else				complete = true;            //Loop through all the children of this node,            //  if the child is a bubbleId            //      complete = (bubble is passed) (AND . OR) (complete)            //  else            //      complete = AreChildComplete(child) (AND.OR) (complete)			for (; child.valid(); child.forth())			{								if(child.data.data is BubbleId)				{					//Util.debug("bubble id comparing" + child.data.data, KpmBubble);					Util.debug(child.data.data.Text + " " + bubbleStatus[child.data.data.Text].Text);					if(pNode.data == "OR")					{						complete = (BubbleStatus[child.data.data.Text].Text == EBStatus.Passed.Text) || complete;						Util.debug("checking or " + complete);					}					else					{						complete = (BubbleStatus[child.data.data.Text].Text == EBStatus.Passed.Text) && complete;						Util.debug("checking and " + complete);					}				}										else				{					if(pNode.data == "OR")					   	complete = areChildComplete(TreeNode(child.data)) || complete;					else if(pNode.data == "AND")						complete = areChildComplete(TreeNode(child.data)) && complete;				}							}						Util.debug("children are complete " + complete);			return complete;		}				//Poset Function        //Helps with traversal of nodes by visiting all children of the node and then coming back to the node		public static function postOrder(node:TreeNode, process:Function, pParentBubble : KpmBubble = null):void		{            //If the bubble has no children, return			if(!node || !node.children)				return;            //Go to all the children first,            //then process the node			var child:DListIterator = node.children.getIterator() as DListIterator;			for (; child.valid(); child.forth())				Kid.postOrder(child.data, process, pParentBubble);							if(pParentBubble)				process(node, pParentBubble);			else 				process(node);		}		public function get BubbleStatus() : Array { return bubbleStatus; }		public function get BubbleAttempts() : Array { return bubbleAttempts; }		public function get BubbleActive() : Array { return bubbleActive; }		public function get Id() : String { return id; }		  	    	public function toString() : String    	{    		return "[Kid : " + firstName + " " + lastName + " (" + age + ")]";    	}    }}