package com.kpm.kpm {	import com.de.polygonal.ds.DListNode;	import com.de.polygonal.ds.Graph;	import com.de.polygonal.ds.GraphArc;	import com.de.polygonal.ds.GraphNode;	import com.de.polygonal.ds.TreeNode;	import com.kpm.util.EGame;	import com.kpm.util.ELanguage;	import com.kpm.util.KpmFtp;	import com.kpm.util.KpmIO;	import com.kpm.util.Util;	//import com.kpm.reporter.excel.InputParser;	//import com.kpm.reporter.excel.Kid;	import com.kpm.ui.UIGod;	import com.kpm.kpm.PosetManager;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.filesystem.File;    import flash.net.URLLoader;    import flash.net.URLRequest;	import flash.xml.XMLNode;public class DriverData extends EventDispatcher	{		//DriverData is a singleton.		private static var instance : DriverData		//Driver is a singleton		private static var driver : Object;		//logTool should probably be a singleton.        public static var logTool			: KpmLogTool ;				//Wether program is invoked via compiler (ADT) or via application launch (KidsPlayMath app)		public static var debugMode : Boolean;				//HOME VERSION (No dropdown menus under booths, no name authentication)		public static const HOME_VERSION		: Boolean = false;        //Controls wether fwd/bwd poset are created for the current PosetProgression XML        public static const CREATE_FWD_AND_BWD_POSET : Boolean = true;				//To identify teacher, check whether player's id is 111111111		public static const TEACHER_ID 			: String  = "111111111";				//First kid created. 9 digit number is not necessary. lets make it 3 digit + the class digit		public static const FIRST_KID_ID 		: String  = "00000000";				//30 seconds for kids to idle and go back to the 'BoothPage'		public static const MAX_IDLE_TIME_KID	: int =  30000;				//300 seconds for kids to idle and go back to the 'BoothPage'		public static const MAX_IDLE_TIME_TEACHER: int =  300000;				//Bubble score visible to the player		public static const SCORE_VISIBLE		: Boolean = true;				//Load the game under stressed conditions. for example. load the game, 1 second after unload it, load it again... many times		public static const TEST_LOAD_GAME		: Boolean = false;				//Wether normal cursor or big cursor is to be used		public static const BIG_CURSOR			: Boolean = false;				//allBubblesUnlocked only if teacher is playing		public static var allBubblesUnlocked 	: Boolean = false;				//only if kid is playing the bubbles are random, the bubbles are progressing and the game is logged		public static var randomBubble			: Boolean = true;		public static var bubbleProgression		: Boolean = false;		public static var log					: Boolean = true;        public static var kidsBubblesNotInServer : Boolean = false;				//logging to ftp is not very much tested		public static var logToFtp				: Boolean = Util.RELEASE;				//Storage for AppData/KidsPlayMath.D3A4D6966A8C4AD45756067BC1473C932482D520/LocalStore and Desktop		// In MAC : Users/x/Library/Preferences/KidsPlayMath.D3A4D6966A8C4AD45756067BC1473C932482D520/LocalStore		public static const FOLDER_APP_STORAGE	: String = "app-storage:/";		public static const FOLDER_DESKTOP		: String = "desktop";				//Storage for buddy icons, games, data, reports, kids		public static const FOLDER_SWF			: String = "swf/";				public static const FOLDER_DATA			: String = "data/";        public static const FOLDER_SEARCH_SETTINGS	: String = "xml/settings.xml";        public static const FOLDER_SEARCH_CONTENTS	: String = "xml/contents.xml";        public static const FOLDER_SEARCH_FILES	: String = "data/search/";        public static const FOLDER_KIDS			: String = "data/kids/";		public static const FOLDER_IMAGE		: String = "data/images/";		public static const FOLDER_ICONS		: String = "data/buddyIcons/";        public static const FOLDER_ICONS_DEST		: String = "KidsPlayMath/Icons/";				public static const FOLDER_KIDSPLAYMATH	: String = "KidsPlayMath/";		public static const FOLDER_REPORTS		: String = "KidsPlayMath/Reports/";					//FTP DATA (we wont use this at all)		public static const FTP_SERVER 			: String  = "www.kidsplaymath.org";		public static const FTP_LOG_PATH		: String  = "data/logs";        public static const FTP_REPORT_PATH		: String  = "data/reports";		public static const FTP_ERROR_PATH 		: String  = "/data/errors";		public static const FTP_PROFILE_PATH	: String  = "/data/register";		public static const FTP_PROFILE_FILE	: String  = "registeredProfiles.xml";		public static const NOT_UPLOADED_FILE	: String  = "data/notUploaded.xml";		public static const FTP_USER 			: String  = "kpmbb@kidsplaymath.org";		public static const FTP_PASSWORD		: String  = "Kpm12301.";		public static const DATA_SENT			: String = "DATA_SENT";		public static const NO_INTERNET			: String = "NO_INTERNET";		public static const FILES_UPLOADED		: String = "FILES_UPLOADED";		public static const FILES_UPLOADING		: String = "FILES_UPLOADING";		//XML FILES		public static const CONFIG_FILE			: String = "data/config.xml";		public static const PDF_REPORT_FILE		: String = "data/pdfReport.xml";		public static const SORTED_BUBBLES_FILE	: String = "data/sortedBubbles.xml";    //Check whether the bubble graph has cycles after generating topographical sort		public static const CYCLE_FOUND			: String = "CYCLE_FOUND";				//Default Values for bubble data, used to generate bubble object from the KID.XML 				public static const DEFAULT_WEIGHT			: uint = 3;		public static const DEFAULT_ENJOY_SCORE 	: int = -1;		public static const DEFAULT_COMPLETE_SCORE 	: int = 1;		public static const DEFAULT_PASS_COUNTER 	: uint = 1;		public static const DEFAULT_FAILED_COUNTER 	: uint = 1;		public static const DEFAULT_TOTAL_TASKS 	: uint = 0;		public static const DEFAULT_MIN_LEVEL	 	: uint = 1;		public static const DEFAULT_MAX_LEVEL	 	: uint = 4;        public static var initFilesNeeded	 		: uint = 0;        public static var isBubbleGroupSubsetEnabled : Boolean = true;		//KPM Consts		//number of standards : SpatialSense, IdentifyNumber, CountNumber, SubsetNumber, DataMeasurements, 		//Geometry, Addition, Comparison		public static const NUM_STANDARDS 		 	: uint = 8;		public static const NUM_GAMES 			 	: uint = 4;		//number of booths in one BoothPage		public static const NUMBER_OF_BOOTHS 		: uint = 5;				public static const MAX_NAMES_PER_STANDARD	: uint = 30;		public static const MAX_LEVELS_PER_BUBBLE	: uint = 8;		public static const MAX_NUM_BUBBLES			: uint = 200;				//standards, bubbleNames, bubbles		//keep everything in xml type data structure with nodes		//Start game, start teacher more, the nomenclature is visualized here				//list of KpmBubbles indexed by the BubbleId in Full Poset		private var bubbleList 	: Array;        //list of KpmBubbles indexed by the BubbleId in Forward Poset        private var fwdPosetBubbleList 	: Array;				//list of all bubbleIds		private var bubbleIds 			: Array = new Array();				//list of Standards indexed by stdIndex		public static var standards			: Array = new Array(DriverData.NUM_STANDARDS);		//2d-list of bubbleNames indexed by stdIndex		public static var bubbleNamesPerStd 	: Array = new Array(DriverData.NUM_STANDARDS);		//List of bubbles indexed by Game ("G1", "G2", "G3", "G4");		private var bubblesPerGame 		: Array = new Array();		//List of bubbles indexed by Game ("G1", "G2", "G3", "G4");		public var gamEBNames 			: Array = new Array();				//PDF Reporter inputParser 		//private var inputParser			: InputParser;				//on KidLogin Page		public static var teacherPassword	: String;				//on PdfReporterPage		public static var isTeacherReport 	: Boolean;				//on BoothPage		public static var languageList 		: Array = [ELanguage.ENG, ELanguage.SPA, ELanguage.OBI];				//English		public var defaultLanguage		: ELanguage = ELanguage.ENG;				//on GamePlay area		public static var accompanied 		: Boolean = false;				//Debug purposes		public var errorStr				: String;    //Other vars to be used for the current class, kid, game, bubble.		public static var currentClass 		: int;				public static var currentGamerId	: String;		public static var selectedKids		: Array;		public static var selectedKidId 	: String;		public static var kidsInfo			: Object;		public static var kidsNames			: Array;		public static var createKid 		: Boolean;		public var bubbleStatus			: Array = new Array();		public static var selectedObject = {ra: 1, rb: 1, ga: 0.75, gb: 0.5, ba: 0, bb: 0};        public var noPredecessorBubbles : Array;        //the current bubble's weight, scores, totaltasks and pass/fail counters		var curWeight 			: Number;		var curCompleteScore 	: Number;		var curEnjoyScore 		: Number;		var curTotalTasks 		: int;		var curPassCounter 		: int;		var curFailedCounter 	: int;        var belongsToFwdPoset, belongsToBwdPoset : Boolean;        //XML DATA		public static var reportXML			: XML;		public static var currentKidXML		: XML;		public static var configXML			: XML;		public var bubbleMenuXML		: XML;				//Kpm IO - Files		public static var configFile 		: KpmIO = new KpmIO();		public static var pdfReportXMLFile 		: KpmIO = new KpmIO();		public var kidFile				: KpmIO = new KpmIO();		public var defaultProfileFile	: KpmIO = new KpmIO();		public static var ftpFile				: KpmFtp = new KpmFtp();        public static var kpmDb            : PhpRequest = new PhpRequest();				//Loading bubble definition from XML		public var bubbleList_Ldr		: URLLoader;		//Holder of the bubbles for the teacher menu in xml format		public var bubbleTreeMenuXMLs	: Array;		//        private var pPredecessorGraph 	: TreeNode;				//Directed Acyclic Graph (DAG), each vertex is a bubble, each edge is a predecessor between bubble b1 and b2		public var dag : Graph;        //Topographical Sorted list of bubbles		public var topographicallySortedBubbleList	: Array ;		private var nodeCounter = 0;	        //Singleton pattern to make it impossible to create varios DriverData objects, and comunicate information        //between objects better		public static function getInstance(pDriver : Object = null): DriverData {        	        	if (instance == null) {        		        		Util.debug("this is the driver " + pDriver);        		driver = pDriver;        		kidsNames = new Array();        		instance = new DriverData();        		          	}          		        return instance;       	} 				public function DriverData() {}		//Initialize bubbles and kid profile		// POSET FUNCTION (all of the functions in DriverData will be used in Posets)        //PUT SWITCH HERE.		public function startProcessingProfile()		{			Util.debug("DriverData.startProcessingProfile");			initialize();            //Download profile from server            //downloadProfile();            kpmDb.isDBOnline();            kpmDb.addEventListener(PhpRequest.NO_INTERNET, populateKidProfileFromXML);            kpmDb.addEventListener(PhpRequest.INTERNET, kpmDb.downloadProfile);            kpmDb.addEventListener(PhpRequest.FIRST_TIME, populateKidProfileFromXML);            kpmDb.addEventListener(PhpRequest.SYNC_PROFILE_DB_TO_LOCAL, syncProfileFromDB);            kpmDb.addEventListener(PhpRequest.LOAD_LOCAL_PROFILE, populateKidProfileFromXML);            kpmDb.addEventListener(PhpRequest.SYNC_PROFILE_LOCAL_TO_DB, syncProfileToDB);        }        //Init list of bubbleIds, standar        // ds, and BubbleNames per standard to be used to populate the DAG        function initialize()        {            bubbleNamesPerStd = new Array(DriverData.NUM_STANDARDS);            for each (var std : EBStd in EBStd.Consts)            {                Util.debug("initailizing array for std " + std.Text + " " + std.Index);                standards[std.Index] = std;                bubbleNamesPerStd[std.Index] = new Array();            }            for each (var bubbleName : EBName in EBName.Consts)            {                for (var i = 1; i <= bubbleName.MaxLevel; i++)                    bubbleIds.push(new BubbleId(bubbleName, i));                //Util.debug("placing bname " + bubbleName.Text + " in standard " + bubbleName.Standard.Text);            }        }        public function syncProfileFromDB(e : Event = null)        {            Util.debug("DriverData.syncProfileFromDB");            currentKidXML = kpmDb.getDBProfileXML();            Util.debug(currentKidXML.toXMLString());        }        public function syncProfileToDB(e : Event = null)        {            Util.debug("DriverData.syncProfileToDB");        }        //BEGIN POPULATING KIDS        public function populateKidProfileFromXML(e : Event = null)        {            kpmDb.removeEventListener(PhpRequest.NO_INTERNET, populateKidProfileFromXML)            populateKidProfileFromXML1(currentGamerId, populateKidProfileFromXML2);        }        function populateKidProfileFromXML1(pKidId : String, pHandlerFunc : Function)        {            Util.debug("DriverData.populateKidProfile" + pKidId);            var kidsProfilePath : String = DriverData.getKidFolder(pKidId) + "_profile.xml";            kidFile.setFilePath(kidsProfilePath);            if(kidFile.exists())            {                kidFile.addEventListener(KpmIO.READ_COMPLETE, pHandlerFunc, false, 0 , true);                kidFile.addEventListener(KpmIO.READ_ERROR, pHandlerFunc, false, 0 , true);                kidFile.read();            }            else            {                logTool.reportError("kid does not exist, cannot access profile", false);            }        }		public function populateKidProfileFromXML2(e : Event)		{            Util.debug("DriverData.populateKidProfileFromXML2 ")			this.bubbleList = new Array();            this.fwdPosetBubbleList = new Array();            //When reading of the xml profile is complete, set the kid profile level (if level is missing) and choose from one of two            //methods.			if(e.type == KpmIO.READ_COMPLETE)			{				currentKidXML = XML(kidFile.readContents);				setKidProfileLevelIfMissing();                //If the kid has no progress yet (if its the first time playing) then populate the kid profile from                //default profile.                //if( kidIsNotBeginner() && !kidProfileHasBubbles())                if(!kidProfileHasBubbles())                    populateKidProfileFromDefaultProfile1();                //else, populate the kid profile from its profile in data/kids/<kidId>/<kidId>_profile.xml                else                {                    Util.debug("populating bubble progression");                    populateBGProgression();                }			}            //report error reading PosetProgression.xml			else if(e.type == KpmIO.READ_ERROR)			{				DriverData.logTool.reportError ("error could not read profile file");			}		}        //This function tells whether or not a kid has started playing before, or if its the first time        public function kidProfileHasBubbles() : Boolean        {            return ("BUBBLE_STATUS" in currentKidXML && currentKidXML.BUBBLE_STATUS.BUBBLE.length() > 0);        }        //when level of the kid is 4 or 5, we populate the kid's profile with a default profile        public function kidIsNotBeginner() : Boolean        {            return (DriverData.currentKidXML.LEVEL == 4 || DriverData.currentKidXML.LEVEL == 5);        }        //Some profiles do not have kid's level, in this case we set level=3 by default		function setKidProfileLevelIfMissing()		{			Util.debug("DriverData.checkKidLevel");						if(!("LEVEL" in currentKidXML) || currentKidXML.LEVEL == null || currentKidXML.LEVEL+"" == "") 				currentKidXML.LEVEL = 3;		}        //BEGIN POPULATING KIDS FROM DEFAULT PROFILE OR ITS OWN PROFILE.XML        //ATTEMPT TO READ THE CORRECT DEFAULT PROFILE (THERE ARE 3 OF THEM, ONE PER LEVEL - 3,4,5)        //When populating the kid's profile is done, attempt to read BGProgression which contains the graph        //describing the bubbles and its relations to each other		function populateKidProfileFromDefaultProfile1()		{			Util.debug("Driver.populateKidProfileFromDefaultProfile");				Util.debug("Kid is not beginner and does not have bubbles");				defaultProfileFile.setFilePath(DriverData.FOLDER_DATA + "defaultProfile" + currentKidXML.LEVEL + ".xml", "app");				defaultProfileFile.addEventListener(KpmIO.READ_COMPLETE, populateKidProfileFromDefaultProfile2, false, 0 , true);				defaultProfileFile.addEventListener(KpmIO.READ_ERROR, populateKidProfileFromDefaultProfile2, false, 0 , true);				defaultProfileFile.read();		}		function populateKidProfileFromDefaultProfile2(e : Event)		{			Util.debug("DriverData.PopulateInfoForNewProfile");            delete currentKidXML.BUBBLE_STATUS;            //SAVE XML CONTENTS OF DEFAULT PROFILE WHEN IT HAS BEEN READ                var defaultKidXML : XML = XML(defaultProfileFile.readContents);                Util.debug(defaultKidXML.toXMLString()) ;                currentKidXML.appendChild(defaultKidXML.BUBBLE_STATUS);            //WRITE IT TO THE APPROPRIATE FILE.                kidFile.write(currentKidXML);			populateBGProgression();		}        //END POPULATING KIDS FROM DEFAULT PROFILE OR ITS OWN PROFILE.XML        function populateBGProgression()		{            if(PosetManager.ENABLE_POSET_NAVIGATION)            {                PosetManager.getInstance().populatePosetProgression();            }            else            {                var myLoader: URLLoader = new URLLoader();                myLoader.addEventListener(IOErrorEvent.IO_ERROR, reportError, false, 0 , true);                Util.debug("loading bubble progression " + PosetManager.POSET_PROGRESSION_FILENAME);                myLoader.load(new URLRequest(DriverData.FOLDER_DATA + PosetManager.POSET_PROGRESSION_FILENAME));                myLoader.addEventListener(Event.COMPLETE, populateBubbleProgressionFromXML, false, 0 , true);            }        }        //BEGIN populating bubble graph. This function is the entry point for PosetProgression.xml        //Loop through all children of BGProgression and make a bubble		function populateBubbleProgressionFromXML(e : Event)		{			var bubbleXML : XML = new XML(e.target.data);			var bubble : KpmBubble;			noPredecessorBubbles = new Array();						for each (var xmlBubble : XML in bubbleXML.*)				saveKpmBubbleVarsFromBubbleGroupXML1(xmlBubble);			populateGames();            Util.debug("pex no predecessor bubbles");            Util.printArray(noPredecessorBubbles);			initLogAndPredecessorGraphAndDAG();						if(DriverData.allBubblesUnlocked)				populateTreeMenus();						}        // BEGIN Create kpmBubble from the XML BubbleGroup it belongs        public function saveKpmBubbleVarsFromBubbleGroupXML1(pBubbleGroupXML : XML)        {            var bubbleNameStr	: String;            var bId 			: BubbleId;            var bubbleName 		: EBName            var equivalenceNum : int ;            equivalenceNum = pBubbleGroupXML.@equivalenceNum;            if(equivalenceNum == 0) equivalenceNum = 1;            for(var i=0; i< equivalenceNum; i++)            {                bubbleNameStr = pBubbleGroupXML["name"][i];                bubbleName = EBName[bubbleNameStr];                curWeight 			= DriverData.DEFAULT_WEIGHT;                curEnjoyScore 		= DriverData.DEFAULT_ENJOY_SCORE;                curCompleteScore 	= DriverData.DEFAULT_COMPLETE_SCORE;                curTotalTasks 		= DriverData.DEFAULT_TOTAL_TASKS;                curPassCounter 		= DriverData.DEFAULT_PASS_COUNTER;                curFailedCounter 	= DriverData.DEFAULT_FAILED_COUNTER;                bubbleName.MinLevel = DriverData.DEFAULT_MIN_LEVEL;                bubbleName.MaxLevel = DriverData.DEFAULT_MAX_LEVEL;                belongsToFwdPoset   = false;                belongsToBwdPoset   = false;                EBName.bubbleGroupList[bubbleName.Text] = pBubbleGroupXML;                if("minLevel" in pBubbleGroupXML)                    bubbleName.MinLevel = pBubbleGroupXML.minLevel;                if("maxLevel" in pBubbleGroupXML)                    bubbleName.MaxLevel = pBubbleGroupXML.maxLevel;                Util.debug("making equivalent bubbles for " + pBubbleGroupXML.name + " " + bubbleName.MinLevel + " " + bubbleName.MaxLevel);                Util.debug("bubbleName " + bubbleNameStr + pBubbleGroupXML.BUBBLE_ID[0]);                Util.debug("std " + bubbleName.Standard);                bubbleNamesPerStd[bubbleName.Standard.Index].push(bubbleName);                //Util.printArray(bubbleNamesPerStd[bubbleName.Standard]);                var bubbleIndex : int = pBubbleGroupXML.BUBBLE_ID[0].LEVEL;                var currentLevel : int = 1;                var bubbleXML : XML = pBubbleGroupXML.BUBBLE_ID[0];                for(var j = 1 ; j <= bubbleName.MaxLevel; j++)                {                    //if another level is specified, and j is already at that level                    if(pBubbleGroupXML.BUBBLE_ID[bubbleIndex+1] && pBubbleGroupXML.BUBBLE_ID[bubbleIndex+1].LEVEL == j)                    {                        currentLevel = pBubbleGroupXML.BUBBLE_ID[bubbleIndex+1].LEVEL;                        bubbleXML = pBubbleGroupXML.BUBBLE_ID[bubbleIndex+1];                        bubbleIndex++;                    }                    bId = BubbleId.makeBIdFromString(bubbleName.Text + "_" + currentLevel);                    Util.debug("will save bubbleId " + bId);                    Util.debug("using index " + bubbleIndex );                    saveKpmBubbleVarsFromBubbleGroupXML2(bId, bubbleXML);                    currentLevel++;                    bubbleXML = new XML();                }            }        }        public function saveKpmBubbleVarsFromBubbleGroupXML2(pBubbleId : BubbleId, pBubbleXML : XML) : KpmBubble        {            Util.debug("DriverData.saveKpmBubbleFromBubbleGroupXML")            var bubbleGroup		: EBName;            var pBubbleId 		: BubbleId;            var pReportStr 		: String;            var pPredecessorList, pSuccessorList : Array;            var pInitialStatus 	: Boolean;            //Checking bubbleID to be saved to 'digital format', to be saved in an array that is accessible all the time            //this is to avoid reading from file all the time.            if(pBubbleId == null || !(pBubbleId is BubbleId))            {                DriverData.logTool.reportError ("error making bubble " + pBubbleXML.BUBBLE_ID + " from XML");            }            if(pBubbleXML == null)            {                pBubbleXML = new XML();                Util.debug("bubble XML is null for bid " + pBubbleId);            }            pSuccessorList = new Array();            Util.debug("levels " + pBubbleXML.LEVEL + " " + pBubbleId.Level + " " + pBubbleId.Name.MinLevel);            Util.debug((int(pBubbleXML.LEVEL) == pBubbleId.Level == pBubbleId.Name.MinLevel) + " " + ("LEVEL" in pBubbleXML));            //if the bubble group has 'initial_status' in the xml, then set the active parameter for the bubble with level 1 of this bubble group            if("INITIAL_STATUS" in pBubbleXML && pBubbleXML.INITIAL_STATUS == "Active")                if(!("LEVEL" in pBubbleXML) || ("LEVEL" in pBubbleXML && (int(pBubbleXML.LEVEL) == pBubbleId.Level && pBubbleId.Level == pBubbleId.Name.MinLevel)))                {                    Util.debug("initial status true for " + pBubbleId)                    pInitialStatus = true;                }                else                    pInitialStatus = false;            //By default if predecessors are not specified, then the predecesosor is the level before this one            if(!("PREDECESSORS" in pBubbleXML) || pBubbleXML.PREDECESSORS.children().length() == 0)            {                var previousBId : BubbleId = new BubbleId(pBubbleId.Name, pBubbleId.Level-1);                pPredecessorGraph = new TreeNode("AND");                pPredecessorGraph.children.append(new TreeNode(previousBId));            }            //If predecessors are specified to None, then save this bubbleId with the bubbles that have no predecessors            else if(pBubbleXML.PREDECESSORS == "none")            {                //Util.debug("predecessors are none");                pPredecessorGraph = null;                noPredecessorBubbles.push(pBubbleId);            }            //Otherwise, loop each one of its children,            else            {                pPredecessorGraph = new TreeNode("AND");                for each ( var xmlPredecessor : XML in pBubbleXML.PREDECESSORS.children())                {                    //if the node is "AND" or "OR", use processPredecessors function to compute the graph of the predecessors                    if (xmlPredecessor.name() == "OR" || xmlPredecessor.name() == "AND")                    {                        pPredecessorGraph = new TreeNode(xmlPredecessor.name());                        createPredecessorsGraph(xmlPredecessor, pPredecessorGraph);                        Util.debug(pPredecessorGraph.dump(), this);                    }                    //otherwise, if the node is a "BUBBLE_ID" then insert it as a predecessor for the current bubble being processed                    else if (xmlPredecessor.name() == "BUBBLE_ID")                    {                        Util.debug("inserting predecessor" + xmlPredecessor, this);                        pPredecessorGraph.children.append(new TreeNode(BubbleId.makeBIdFromString(xmlPredecessor)));                    }                }            }            //Util.debug("current bubble " + pBubbleId);            //Util.debug("enjoy score xml " + pBubbleXML["ENJOY_SCORE"]);            //Util.debug("curEnjoyScore " + curEnjoyScore);            //Util.debug("curWeight " + curWeight);            //Util.debug("weight xml " + pBubbleXML["WEIGHT"]);            //if the weight is defined by the xml, then use that            if("WEIGHT" in pBubbleXML) 				curWeight 		 = pBubbleXML["WEIGHT"];            if("ENJOY_SCORE" in pBubbleXML)			curEnjoyScore 	 = pBubbleXML["ENJOY_SCORE"];            if("COMPLETE_SCORE" in pBubbleXML)  	curCompleteScore = pBubbleXML["COMPLETE_SCORE"];            if("PASS_COUNTER" in pBubbleXML)		curPassCounter 	 = pBubbleXML["PASS_COUNTER"];            if("FAIL_COUNTER" in pBubbleXML)		curFailedCounter = pBubbleXML["FAIL_COUNTER"];            if("FWD_POSET" in pBubbleXML && pBubbleXML["FWD_POSET"] == "true")                belongsToFwdPoset = true;            if("BWD_POSET" in pBubbleXML && pBubbleXML["BWD_POSET"])                belongsToBwdPoset = true;            //This is specially for Spatial Sense bubbles,            if(pBubbleId.Name == EBName.SpatialSense)            {                curEnjoyScore = 0.6;                curCompleteScore = 0.8;            }            //TO CHECK : Total Tasks : this should go with the bubble!            pBubbleId.TotalTasks = curTotalTasks;            if(curTotalTasks > 0 )                Util.debug("total tasks " + pBubbleId + " " + curTotalTasks, this);            //Create a new bubble            var newBubble : KpmBubble = new KpmBubble(pBubbleId, curWeight, pInitialStatus, pPredecessorGraph, pSuccessorList,                    curEnjoyScore, curCompleteScore, curPassCounter, curFailedCounter, pReportStr, belongsToFwdPoset, belongsToBwdPoset);            //Add new kpm Bubble to the array of KpmBubbles            Util.debug("adding " + newBubble + " to index " + pBubbleId.Text);            bubbleList[pBubbleId.Text] = newBubble;            if(belongsToFwdPoset)                fwdPosetBubbleList[pBubbleId.Text] = newBubble;            return newBubble;        }        // Creating predecessorsGraph        public function createPredecessorsGraph(pPredecessors : XML, pParent : TreeNode)        {            var child : DListNode;            for each ( var xmlPredecessor : XML in pPredecessors.children())            {                Util.debug("processing " + xmlPredecessor, this);                if (xmlPredecessor.name() == "OR" || xmlPredecessor.name() == "AND")                {                    child = pParent.children.append(new TreeNode(xmlPredecessor.name()));                    createPredecessorsGraph(xmlPredecessor, TreeNode(child.data));                }                else if (xmlPredecessor.name() == "BUBBLE_ID")                {                    //Util.debug("appending " + xmlPredecessor, this);                    pParent.children.append(new TreeNode(BubbleId.makeBIdFromString(xmlPredecessor)));                }            }        }        // END Create kpmBubble from the XML BubbleGroup it belongs        public function selectNextClass()        {            Util.debug("current id " + DriverData.configXML.classes.@currentId);            var currentClassXML : XML = DriverData.configXML.classes.children().(@id == DriverData.configXML.classes.@currentId)[0];            if(!currentClassXML)            {                DriverData.configXML.classes.@currentId = DriverData.configXML.classes.children()[0].@id;                if(!Util.RELEASE)                    throw new Error("current class id was not found");            }            Util.debug("next class index " + (currentClassXML.childIndex() + 1)%DriverData.configXML.classes.children().length());            var nextClassXML : XML  = DriverData.configXML.classes.children()[(currentClassXML.childIndex() + 1)%DriverData.configXML.classes.children().length()];            DriverData.configXML.classes.@currentId = int(nextClassXML.@id);            Util.debug("current id " + DriverData.configXML.classes.@currentId);            DriverData.configFile.write(DriverData.configXML);            //Util.debug("nextclass " + DriverData.configXML.classes.children()[DriverData.configXML.classes.@currentId].@name.toXMLString().indexOf("deleted"));        }        //POSET FUNCTION		//Each game gets a list of bubbles that can be implemented by that game		//Each element of fullPosetBubbleList gets added a list of games that can implement that bubble		private function populateGames()		{			Util.debug("DriverData.populateGames");            //HardCode Data Entry to answer the question, which bubbles can be implemented by which games			gamEBNames = new Array(DriverData.NUM_GAMES);			gamEBNames[EGame.G1.Text] = [EBStd.SpatialSense, EBName.IdentifyColor, EBName.IdentifySize, EBStd.Numbers_Count, EBStd.Numbers_Identify, EBStd.Numbers_Subset];			gamEBNames[EGame.G2.Text] = [EBName.IdentifyShape, EBName.IdentifyColor, EBName.MatchShape, EBName.PlaceShapeA, EBName.PlaceShapeB, EBName.PlaceShapeC];			gamEBNames[EGame.G3.Text] = [EBName.IdentifyColor, EBName.IdentifySize, EBStd.Numbers_Count, EBStd.Numbers_Subset, EBStd.Numbers_Identify];			gamEBNames[EGame.G4.Text] = [EBStd.Numbers_Count, EBStd.Numbers_Subset, EBStd.Addition, EBStd.Comparison, EBStd.Numbers_Identify];            gamEBNames[EGame.G4.Text] = [EBStd.PlaceNumber];            var exceptionsBubblesPerGame : Array = new Array(4);			exceptionsBubblesPerGame[EGame.G3.Text] = [ new BubbleId(EBName.Identify5Frame, 5), new BubbleId(EBName.Identify5Frame, 6), new BubbleId(EBName.IdentifyNumeral, 5), new BubbleId(EBName.IdentifyNumeral, 6)];            //Maximum number of elements allowed per game for different bubbles            //compared to the maximum number of elements for different bubbles			var maxArrayCount = new Array(DriverData.NUM_GAMES);			maxArrayCount[EGame.G1.Text] = 10;			maxArrayCount[EGame.G2.Text] = 0;			maxArrayCount[EGame.G3.Text] = 10;			maxArrayCount[EGame.G4.Text] = 20; 						var maxArraySubset = new Array(DriverData.NUM_GAMES);			maxArraySubset[EGame.G1.Text] = 10;			maxArraySubset[EGame.G2.Text] = 0;			maxArraySubset[EGame.G3.Text] = 7;			maxArraySubset[EGame.G4.Text] = 20; 						var maxArrayIdentify = new Array(DriverData.NUM_GAMES);			maxArrayIdentify[EGame.G1.Text] = 6;			maxArrayIdentify[EGame.G2.Text] = 0;			maxArrayIdentify[EGame.G3.Text] = 4;			maxArrayIdentify[EGame.G4.Text] = 6;									bubblesPerGame = new Array(EGame.Consts.length);						for each (var egame : EGame in EGame.Consts)				bubblesPerGame[egame.Text] = new Array();									//bubbleTreeMenus[EGame.G1.Text] = new TreeMenu(bubbleTreeMenuXMLs[EGame.G1.Text]);			//			for (var game : String in gamEBNames)			{				for each ( var bubbleGroup in gamEBNames[game])				{					if(bubbleGroup is BubbleId)					{						var bId : BubbleId = bubbleGroup as BubbleId;						if(bubbleList[bId.Text])							bubbleList[bId.Text].addGame(game);						Util.debug("bubbleGroup: populate " + bId.Text + " to game " + game, this);						bubblesPerGame[game].push(bId); 					}										else if(bubbleGroup is EBName)					{						var bName1 : EBName = bubbleGroup as EBName; 						for (var i = 1; i <= bName1.MaxLevel; i++)						{														var bId2 = new BubbleId(bName1, i);														if(!Util.searchInArray(exceptionsBubblesPerGame[game], bId2))							{								Util.debug("EBName " + (bName1.Text+"_"+i) + " to game " + game, this);								if(bubbleList[bName1.Text+"_"+i])									bubbleList[bName1.Text+"_"+i].addGame(game);																bubblesPerGame[game].push(bId2);							}						}					}					else if(bubbleGroup is EBStd)					{						var standard : EBStd = bubbleGroup as EBStd;						var bubbleNames : Array = bubbleNamesPerStd[standard.Index];																		for each (var bName2 : EBName in bubbleNames)						{							if((standard == EBStd.Numbers_Count && maxArrayCount[game] < EBName.countNumber(bName2)) || 								(standard == EBStd.Numbers_Subset && maxArraySubset[game] < EBName.countNumber(bName2))) 							{								Util.debug("breaking for game " + game + "at " + bName2);							}															else 							{									for (var j = 1; j <= bName2.MaxLevel; j++)								{									Util.debug("standard " + standard + " game " + game + "maxarray at game " + maxArrayIdentify[game] + " j " + j);																		if(standard == EBStd.Numbers_Identify && (maxArrayIdentify[game] > 0 && maxArrayIdentify[game] < j))									{										Util.debug("identify bigger than allowed level ");										}																		else if(bubbleList[bName2.Text+"_"+j])									{										Util.debug("Standard : adding "+ bName2 + " " + j);																				bubblesPerGame[game].push(new BubbleId(bName2, j));										if(bubbleList[bName2.Text+"_"+j])											bubbleList[bName2.Text+"_"+j].addGame(game);									}								}							}							}					}						}			}		}        // BEGIN PROCESSING GRAPH        // POSET FUNCTION        function initLogAndPredecessorGraphAndDAG()		{			Util.debug("finish initialize kid");			computeSuccessors1fromPredecessors();			populateDAG();			topologicalSort();            initLog();			this.dispatchEvent(new Event(Event.COMPLETE));		}				function initLog()		{			logTool.createLogFile(currentKidXML);			logTool.createSession();			logTool.writeBubblesSorted();		}        //BEGIN COMPUTING SUCCESSORS        //Schedule a PostOrder operation on the graph predecessorList		public function computeSuccessors1fromPredecessors()		{			//Util.debug("populating successors", this);						for each (var bubble : KpmBubble in bubbleList)			{				if(bubble.predecessorGraph[PosetManager.CurrentPoset])				{					//Util.debug("populating successors for " +  bubble, this);					com.kpm.kpm.Kid.postOrder(bubble.predecessorGraph[PosetManager.CurrentPoset], computeSuccessors2fromPredecessors, bubble);				}				 			}			//Util.debug("end populating successors", this);		}        // Post order operation		public function computeSuccessors2fromPredecessors(pNode : TreeNode, pParentBubble : KpmBubble)		{			//Util.debug(pNode.data, this);			if(pNode.data is BubbleId)			{				Util.debug("adding successor " + pParentBubble.Id + " to " + pNode.data, this);				if(!bubbleList[pNode.data.Text])					DriverData.logTool.reportError(pNode.data.Text + " does not exist");				bubbleList[pNode.data.Text].successorList[PosetManager.CurrentPoset].push(pParentBubble.Id)			}		}        //END COMPUTING SUCCESSORS        // The list of kpm bubbles created from the xml bubble group from the PosetProgression.xml file        // gets saved as a Directed Acyclic Graph (list of vertices or nodes and edges)		function populateDAG()		{			dag = new Graph(200);            //Add nodes (all bubbles)			for each (var bubble : KpmBubble in bubbleList)			{				nodeCounter++;				dag.addNode(bubble.Id, nodeCounter);				bubble.nodeIndex = nodeCounter;				//Util.debug("adding to DAG " + bubble.Id + " " + nodeCounter, this); 			}            //add two arcs whenever an edge is found (one from b1 to b2 one from b2 to b1)			for each (var b1 : KpmBubble in bubbleList)			{				for each (var bId : BubbleId in b1.successorList[PosetManager.CurrentPoset])				{					var b2 : KpmBubble = bubbleList[bId.Text];					dag.addArc(b1.nodeIndex, b2.nodeIndex, 1);					dag.addArc(b2.nodeIndex,b1.nodeIndex, -1);					//Util.debug("adding arc " + b1.Id + " " + b1.nodeIndex + " " + b2.Id + " " + b2.nodeIndex, this);				}							}										}		        // Topological Sorting		function topologicalSort()		{            //        L ← Empty list that will contain the sorted elements (a.k.a. topographicallySortedBubbleList)            //        S ← Set of all nodes with no incoming edges			topographicallySortedBubbleList = new Array();			Util.debug("pexxxx " + noPredecessorBubbles.length);						var S : Array = noPredecessorBubbles;						Util.debug("starting topological sort", this);            //while S is non-empty do			while (S.length != 0)			{				i++;				var i : int = Util.getRandBtw(0, S.length-1);				var bId : BubbleId;                // remove a node n with index i from S				bId = (S.splice(i,1))[0];                // if the element is already in the topographicallySortedBubbleList                if(Util.searchInArray(topographicallySortedBubbleList, bId))				{					errorStr = bId + " is already in sortedBubbles. Cycle found !";						logTool.reportError(errorStr);					this.dispatchEvent(new Event(DriverData.CYCLE_FOUND));					return; 				}                // insert n into L                topographicallySortedBubbleList.push(bId);								//Util.debug("topsort bid " + bId , this);				var node1  : int = bubbleList[bId.Text].nodeIndex;                //Outgoing nodes from dag                var outgoingEdges : Array = dag.nodes[node1].OutgoingNodes;								Util.debug("topsort bid " + bId + " " + node1 + " " + dag.nodes[node1].data, this);                //for each node m with an edge e from n to m do                //   remove edge e from the graph                //        if m has no other incoming edges then                //        insert m into S                for each (var node2 : GraphNode in outgoingEdges)				{					//Util.debug("removing " + dag.nodes[node1].data + " " + node2.data, this);					dag.nodes[node1].removeArc(node2);					node2.removeArc(dag.nodes[node1]);									if(node2.IncomingNodes.length == 0)					{						//Util.debug("adding " + node2.data, this);						S.push(node2.data);					}				}			}            // if graph has edges then            //     return error (graph has at least one cycle)			errorStr = "";			for each (var node : GraphNode in dag.nodes)			{				for each( var arc : GraphArc in node.arcs)				{					errorStr = "graph has cycles, or some components are not connected : ";					errorStr += node.data + " ";					errorStr += arc.node.data;										Util.debug(errorStr, this);				}			}						if(errorStr != "")			{				logTool.reportError(errorStr);				this.dispatchEvent(new Event(DriverData.CYCLE_FOUND));			}		}        // END PROCESSING GRAPH        //BEGIN RELOAD KIDS PROFILE INFO (kidID, Name, LastName, Age...) usando un inputParser para guardar la info del nino        public function reloadKidsProfileInfo1(pForceUpdate : Boolean = false):void{            //inputParser = new InputParser(KpmIO.DEFAULT_LOCATION.nativePath + "//" + DriverData.getKidFolder());            //inputParser.addEventListener("kidLoaded", reloadKidsProfileInfo2, false, 0 , true);            //inputParser.addEventListener("endOfParsing", reloadKidsProfileInfo3, false, 0 , true);            //inputParser.addEventListener("noKids", noKidsEvent, false, 0 , true);            if(!kidsNames[DriverData.configXML.classes.@currentId] || pForceUpdate)            {                Util.debug("forceUpdate");                kidsInfo = new Object();                kidsNames[DriverData.configXML.classes.@currentId] = new Object();                inputParser.loadDir(null);                inputParser.loadNextKid();            }            else            {                Util.debug("reusing kidsinfo");                kidsInfo = kidsNames[DriverData.configXML.classes.@currentId];                reloadKidsProfileInfo3(null);            }        }        //Recorre las burbujas correspondientes al niño actual        private function reloadKidsProfileInfo2(e:Event):void{            //var kid : com.kpm.reporter.excel.Kid = inputParser.getKid();            Util.debug("kid id " + kid.uid());            //Guarda la informacion            kidsInfo[kid.uid()+""] = kid;            kidsNames[DriverData.configXML.classes.@currentId][kid.uid()+""] = kid;            inputParser.loadNextKid();        }        private function reloadKidsProfileInfo3(e : Event)        {            this.dispatchEvent(new Event("endOfParsing"));            inputParser.removeEventListener("kidLoaded", reloadKidsProfileInfo2);            inputParser.removeEventListener("endOfParsing", reloadKidsProfileInfo3);            inputParser.removeEventListener("noKids", noKidsEvent);            Driver.tLoadingPage.visible = false;            Util.debug("finish loading kids");            for (var p in DriverData.kidsInfo)            {                Util.debug(p);            }        }        //Whenever the KIDS_FOLDER is empty        private function noKidsEvent(e : Event)        {            Util.debug("class has no kids");            this.dispatchEvent(new Event("noKids"));            inputParser.removeEventListener("kidLoaded", reloadKidsProfileInfo2);            inputParser.removeEventListener("endOfParsing", reloadKidsProfileInfo3);            inputParser.removeEventListener("noKids", noKidsEvent);        }        public static function validKidFolder(pName : String)        {            Util.debug("Checking valid kid folder " + pName.charAt(0) + " " +  DriverData.configXML.classes.@currentId);            if(pName.charAt(0) == DriverData.configXML.classes.@currentId)                if(pName != DriverData.TEACHER_ID && pName.length == 10)                    return true;            else if(pName.length == 9 && pName != DriverData.TEACHER_ID && PosetManager.ENABLE_POSET_NAVIGATION)                UIGod.feedback("profile is of older version");            //if(pName.charAt(0) == String(DriverData.currentClass))            return false;        }        public static function switchProfileToUniqueId(pKidId : String)        {            var pFromProfile : KpmIO;            var pToProfile : KpmIO;            var pFromFolder : KpmIO;            var pToFolder : KpmIO;            var pFromJpg : KpmIO;            var pToJpg : KpmIO;            var newID : String;            if(pKidId.slice(1,5) == "0000")            {                pFromProfile = new KpmIO();                pToProfile = new KpmIO();                pFromFolder = new KpmIO();                pToFolder = new KpmIO();                pFromJpg = new KpmIO();                pToJpg = new KpmIO();                newID = pKidId.charAt(0) + String(Util.getSecondsFrom1970() % 100000000 + pKidId.charAt(pKidId.length-1));                Util.debug("DriverData.switchProfileToUniqueId from " + pKidId)                Util.debug("DriverData.switchProfileToUniqueId to " + newID)                Util.debug("Profile is older");                Util.debug("renaming folder");                pFromProfile.setFilePath(DriverData.getKidFolder(pKidId) + "_profile.xml");                pToProfile.setFilePath(DriverData.getKidFolder(newID)  + "_profile.xml");                try{                    pFromProfile.mFile.moveTo(pToProfile.mFile, true);                }                catch (error:Error){                    trace("Error:" + error.message);                }                Util.debug("renaming jpg file");                pFromJpg.setFilePath(DriverData.getKidFolder(pKidId) + ".jpg");                pToJpg.setFilePath(DriverData.getKidFolder(newID) + ".jpg");                try{                    pFromJpg.mFile.moveTo(pToJpg.mFile, true);                }                catch (error:Error){                    trace("Error:" + error.message);                }                pFromFolder.setFilePath(DriverData.getKidFolder() + pKidId);                pToFolder.setFilePath(DriverData.getKidFolder() + "/recyclebin/" +  Util.getTodayDate("compact")  + "/" + pKidId);                try{                    pFromFolder.mFile.moveTo(pToFolder.mFile, true);                }                catch (error:Error){                    trace("Error:" + error.message);                }                var kidFile : KpmIO = new KpmIO();                populateKidProfileFromXML1(newID, changeID);                function populateKidProfileFromXML1(pKidId : String, pHandlerFunc : Function)                {                    Util.debug("DriverData.populateKidProfile" + pKidId);                    var kidsProfilePath : String = DriverData.getKidFolder(pKidId) + "_profile.xml";                    kidFile.setFilePath(kidsProfilePath);                    if(kidFile.exists())                    {                        kidFile.addEventListener(KpmIO.READ_COMPLETE, pHandlerFunc, false, 0 , true);                        kidFile.addEventListener(KpmIO.READ_ERROR, pHandlerFunc, false, 0 , true);                        kidFile.read();                    }                    else                    {                        logTool.reportError("kid does not exist, cannot access profile", false);                    }                }                function changeID(e : Event)                {                    if(e.type == KpmIO.READ_COMPLETE)                    {                        var changingKidIdXML : XML = XML(kidFile.readContents);                        changingKidIdXML.UID = newID;                        kidFile.write(changingKidIdXML);                    }                }            }            function deletedKidSuccessfully (e : Event)            {               Util.debug("deleting kid for new version");            }        }        //Teacher Mode : move kid's folder to recycle bin,        // to avoid deleting the kid's progress while removing it from the UI of the game        public function moveKidToTrash( pKidId : String, pHandler : Function)        {            var pFrom : KpmIO = new KpmIO();            var pTo : KpmIO = new KpmIO();            pFrom.setFilePath(DriverData.getKidFolder() + pKidId);            pTo.setFilePath(DriverData.getKidFolder() + "/recyclebin/" +  Util.getTodayDate("compact")  + "/" + pKidId);            if(pFrom.exists())            {                KpmIO.copyToAsync(pFrom, pTo, pHandler, null, true);                UIGod.feedback("Deleted kid " + DriverData.kidsInfo[pKidId].firstName() + " " + DriverData.kidsInfo[pKidId].lastName() + " successfully");            }        }        //END : RELOAD KIDS PROFILE INFO        //BEGIN UTILTY TYPE FUNCTIONS		public function reportError(event : IOErrorEvent)		{			logTool.reportError("error " + event.errorID + " : " + event.type + " " + event.text);		}						public static function getKidFolder(pKidId : String = null)		{			if(pKidId)				return DriverData.KpmFolder + DriverData.FOLDER_KIDS + pKidId + "/" + pKidId;			else				return DriverData.KpmFolder + DriverData.FOLDER_KIDS;		}				public static function get KpmFolder() : String		{            Util.debug("DriverData.KpmFolder Default location : " + KpmIO.DEFAULT_LOCATION.nativePath + ". Documents Directory : " + File.documentsDirectory.nativePath) ;			if(KpmIO.DEFAULT_LOCATION.nativePath == File.documentsDirectory.nativePath)				return DriverData.FOLDER_KIDSPLAYMATH;			else 				return "";			}				public static function getFolderName(fullPath : String) : String		{			return Util.getFileName(fullPath);			}        //END UTILTY TYPE FUNCTIONS        //BEGIN GETTERS/SETTERS		public static function get Driver()			: Object 	{ return driver;}				public function get BubbleList() 		: Array { 	return bubbleList;}		public function get BubblesPerGame() 	: Array	{	return bubblesPerGame;}        public function get BubbleNamesPerStd() : Array { 	return bubbleNamesPerStd; }        public function get BubbleIds() 		: Array { 	return bubbleIds;}    //END GETTERS AND SETTERS        //BEGIN POPULATING TREE MENUS for Teacher Mode        // NOT A POSET FUNCTION        function populateTreeMenus()        {            var stdIndex , nameIndex : uint;            var stdXML : XML;            var  nameXML, levelXML : XML ;            var stdXMLNodes : XMLNode;            var nameXMLNodes : XMLNode;            bubbleTreeMenuXMLs = new Array(EGame.Consts.length);            for each (var game1 : EGame in EGame.Consts)                bubbleTreeMenuXMLs[game1.Text] = new XML(<menu></menu>);            for (var i=0; i<DriverData.NUM_STANDARDS; i++)            {                //sortedBubbles3[i] = new Array(DriverData.MAX_NAMES_PER_STANDARD);                stdXML = new XML(<m n="standard"></m>);                Util.debug("length bubbleNames" + bubbleNamesPerStd[i].length, this);                for (var j=0; j< bubbleNamesPerStd[i].length; j++)                {                    //sortedBubbles3[i][j] = new Array(DriverData.MAX_LEVELS_PER_BUBBLE);                    stdXML.appendChild(new XML(<m n="name"></m>));                }                for each (var game2 : EGame in EGame.Consts)                    bubbleTreeMenuXMLs[game2.Text].appendChild(new XML(stdXML.toString()));            }            for each (var game : EGame in EGame.Consts)            {                for each(var bId : BubbleId in bubblesPerGame[game.Text])                {                    var bubble : KpmBubble = bubbleList[bId.Text];                    if(bubble.games[game.Text])                    {                        nameIndex = bId.Name.Index;                        stdIndex =  bId.Name.Standard.Index;                        Util.debug("populating menu for " + bId.Text + " " + stdIndex + " " + nameIndex + " " + game.Text, this);                        stdXML = bubbleTreeMenuXMLs[game.Text].m[stdIndex];                        nameXML = stdXML.m[nameIndex];                        if(stdXML.@n == "standard")                            stdXML.@n = bId.Name.Standard.ReadableText;                        if(nameXML.@n == "name")                            nameXML.@n = bId.Name.Text;                        // SmallGroups	<m n="" id="" color="">                        if(nameXML.@n.indexOf("IdentifyFinger") != -1 || nameXML.@n.indexOf("IdentifyNumeral") != -1 || nameXML.@n.indexOf("Identify5Frame") != -1 || nameXML.@n.indexOf("IdentifyDiceDots") != -1 || nameXML.@n.indexOf("IdentifyMixed") != -1)                            nameXML.appendChild(new XML(<m n={"Up to " + EBName.numbers[bId.Text.split("_")[1]]} id={bId.Text}></m>));                        else                            nameXML.appendChild(new XML(<m n={"Level" + bId.Level} id={bId.Text}></m>));                    }                }                removeEmptyNodes(game.Text);                Util.debug("printing xml for menu");                Util.debug(bubbleTreeMenuXMLs[game2.Text].toXMLString());            }        }        function removeEmptyNodes(pGame : String)        {            for (var std =0; std < DriverData.NUM_STANDARDS; std++)            {                for (var name =0; name < bubbleNamesPerStd[std].length; )                {                    if(bubbleTreeMenuXMLs[pGame].m[std])                    {                        if(bubbleTreeMenuXMLs[pGame].m[std].@n == "standard")                        {                            Util.debug("removing standard", this);                            delete bubbleTreeMenuXMLs[pGame].m[std];                        }                        else                        {                            if(bubbleTreeMenuXMLs[pGame].m[std].m[name] &&                                    bubbleTreeMenuXMLs[pGame].m[std].m[name].@n == "name")                            {                                Util.debug("removing name", this);                                delete bubbleTreeMenuXMLs[pGame].m[std].m[name];                            }                            else                                name++;                        }                    }                    else                        name++;                    trace("removing name " + name + "std " + std);                }                trace("removing std " + std);            }        }        //END POPULATING TREE MENUS for Teacher Mode				}		}