package com.kpm.games.game5 {	import com.kpm.util.*;import com.kpm.games.walkthewalk.GCMovement;import com.kpm.kpm.BubbleId;	import com.kpm.games.EGameCharacter;import com.kpm.kpm.EBName;import com.kpm.kpm.EBStd;import com.vuzum.search.Search;import flash.display.MovieClip;import flash.display.Stage;import flash.events.Event;public class G5Lib extends GameLib    {        //THIS SOFTWARE GENERATES A PATH OF mpNumTotalNodesInPath POSITIONS        //STARTING AT mpPathInitialValue        //INITIAL VALUE OF THE PATH        public const mpInitialNumeral              : int = 0;        //Number of Positions or Nodes (Path = [list of Nodes : Pieces+Wholes]        public const mpNumTotalNodesInPath            : int = 1;        //Present objects at random from the hole set        public const mpNumAnswersToChoose               : uint = 2;        public const mpNumPresentations                 : uint = 3;        //First it puts a random number of numberals between a min and a max        //Then it puts a random number of wholes between a min and a max        //This is the best way to populate the pieces and wholes        //as we have a fine control over the progression        public const mpMinRandomAdjacentPieces        : int = 4;        public const mpMaxRandomAdjacentPieces     : int = 5;        public const mpMaxRandomAdjacentWholes     : int = 6;        public const mpMinRandomAdjacentWholes     : int = 7;        public const mpOrder     : int = 8;        private var _mPiecesList : Array;        private var _mHoles : Array;        private var _mAnswerBoxCounters : Array;        private var _mNodes : Array;        private var _mAnimatingNodes : Array;        public static const ANSWER_BOX_POSITION    : Array = [440,750];        public static const ANSWER_BOX_SIZE        : Array = [424,156];        public static const COUNTERS_HEIGHT : int = 155;        public static const MAX_NUM_ROAD_1 : int = 11;        public static const MAX_NUM_ROAD_2 : int = 21;        public static const MAX_NUM_ROAD_3 : int = 41;        public static const NUM_PARAMETERS : int = 10;        public function G5Lib(params : Object, pLanguage : ELanguage, pGame : Object, pChar : EGameCharacter){            super(params, pLanguage, pGame);            if(_mPiecesList) _mPiecesList.splice(0);            else _mPiecesList = new Array();            if(_mNodes)_mNodes.splice(0);            else _mNodes = new Array();            if(_mHoles)_mHoles.splice(0);            else _mHoles = new Array();            _mAnswerBoxCounters = new Array();            characters = ["G5Character1", "G5Character2"]		    soundLibrary.createLibrary(pLanguage, gameId, pChar, params.PosetName);            //soundLibrary.addLibSound(ESoundType.Instruction, null, pLanguage, EGame.G5,null, EBStd.PlaceNumber);        }        public function removeLists(e : Event)        {            if(_mPiecesList) _mPiecesList.splice(0);            if(_mNodes)_mNodes.splice(0);            if(_mHoles)_mHoles.splice(0);        }            //Actualiza variables para cada bubble usando el quality, Bubble.Name y Bubble.Level        public function initGameGoal(pNumPresentations , pGoal : EGoal){            Util.debug("Game5.initGameGoal" + pNumPresentations + " " + pGoal);            //super.updateGoal();            gameGoal = new Goal(pNumPresentations , EGoal.PLACE_NUMBER);        }		//$ update the variables that change per task.		public function updateGameGoal(pGoal : Number){            Util.debug("Game5.updateGameGoal")			var i=0;						do			{				switch (gameGoal.quality)                {					case EGoal.PLACE_NUMBER: 	 CurrentGoal = pGoal; break;				}				i++;			}			while (gameGoal.currentGoal == gameGoal.pastGoal && i < 10);						gameGoal.pastGoal = gameGoal.currentGoal;			//*starts a task/round			resetTask();            taskTimer.start();            simulateMouseMoving();		}        public function outputParameters()        {//            Util.printArray(["mpPathInitialValue", paramsList[0],//                            "mpNumTotalNodesInPath", paramsList[1],//                            "mpNumAnswersToChoose : ", paramsList[2],//                            "mpNumPresentations : ", paramsList[3],//                            "mpMaxRandomNumAdjacentPieces", paramsList[4],//                            "mpMinRandomNumAdjacentPieces",paramsList[5],//                            "mpMaxRandomNumAdjacentWholes", paramsList[6],//                            "mpMinRandomNumAdjacentWholes",paramsList[7],//                            "mpOrder",paramsList[8],//                            "mpLanguage",paramsList[9]],////                            "Initializing Parameters");        }        //SCORING????        //for now scoring is done based on path or based on choice.        //should we have a new way of        // pType        public function generateGroup(pFirstNumber : int, pType : EG5PieceType, pHowMany : int)        {            var nodes : Array = new Array();                          -            Util.debug("Generating Group of " + pHowMany);            for (var i=0; i < pHowMany; i++)            {                nodes.push(new Object());                nodes[i].whole = (pType == EG5PieceType.WHOLE);                    nodes[i].index = _mNodes.length + i + 1;                nodes[i].numeral = pFirstNumber + i;                with (nodes[i]){Util.printArray(["nodes[i]: .whole : ", whole, ", .index : " , index , ", .numeral : " , numeral] , "generateGroup") ; }            }            return nodes;        }            public function newCounter(index : int, numeral : int, stage : Stage, pArray : Array, pColor : EColor = null)        {            Util.debug("G5Data.newCounter");            var counter : Counter = new Counter(ENumberForm.Numeral, numeral, stage);            pArray[index] = new GameComponent();            pArray[index].MovieName = "BoxCoverGray";            pArray[index].numeral = numeral;            if(pColor) colorPiece(pArray[index], pColor);            pArray[index].addMovieClipAbove(counter, false, -100);            pArray[index].feedbackSound = ENumber.numbers[numeral];            pArray[index].x = G5Lib.ANSWER_BOX_POSITION[Util.INDEX_X] + (index* 115);            pArray[index].y = G5Lib.ANSWER_BOX_POSITION[Util.INDEX_Y];            pArray[index].scaleX *= 0.6;            pArray[index].scaleY *= 0.7;        }        public function addNodesToPath(pNodes : Array) : int        {            for(var i = 0; i < pNodes.length; i++)                _mNodes.push(pNodes[i]);            Util.printArray(pNodes, "addNodesToPath");            return pNodes.length;        }        public function colorPiece(pGC : GameComponent, pColor : EColor)        {            if (!pGC.numeral) pGC.ColorAll = pColor;            Util.printArray(["pGC.numeral", pGC.numeral], "colorPiece");            scalePiece(pGC,  pGC.numeral);            if((pGC.numeral % 10) == 0)                pGC.ColorAll = EColor.Yellow;            else if((pGC.numeral % 5) == 0)                pGC.ColorAll = EColor.Orange;            else if(pColor != null)                pGC.ColorAll = pColor;            else throw ("pColor is null colorPiece");        }    public function scalePiece(pGC : GameComponent, numeral : int)    {        Util.printArray(["pGC.numeral", numeral], "scalePiece");        if((numeral % 10) == 0)            pGC.Movie.Scale *= 1.5;        else if((numeral % 5) == 0)            pGC.Movie.Scale *= 1.2;    }    public function initializeParameters()    {        paramsList = new Array(NUM_PARAMETERS);        paramsList[mpInitialNumeral] = params.mpInitialNumeral;        paramsList[mpNumTotalNodesInPath] = params.mpNumTotalNodesInPath;        paramsList[mpNumAnswersToChoose] = params.mpNumAnswersToChoose  ;        paramsList[mpNumPresentations]= params.mpNumPresentations;        paramsList[mpMinRandomAdjacentPieces] = params.mpMinRandomAdjacentPieces;        paramsList[mpMaxRandomAdjacentPieces] = params.mpMaxRandomAdjacentPieces;        paramsList[mpMinRandomAdjacentWholes] = params.mpMinRandomAdjacentWholes ;        paramsList[mpMaxRandomAdjacentWholes] = params.mpMaxRandomAdjacentWholes;        paramsList[mpOrder] = params.mpOrder ;        Util.printArray(paramsList, "parameters Initialized!");    }    public function initializeAudio()    {        Util.debug("initializeAudio");        var numeralIndex=0;        //Add all sounds between the numerals of the game divisible by 5.        //example, if first number is 17, last is 40, then 20,25,30,35 should be added        for (numeralIndex = paramsList[mpInitialNumeral]; true; numeralIndex++){            Util.debug("finding numeral index " + numeralIndex);            if(numeralIndex%5==0) break;        }        for (var j :int =numeralIndex; j < paramsList[mpNumTotalNodesInPath]; j = j+5){            Util.debug("j " + j + " numeralIndex " + numeralIndex + " " + paramsList[mpNumTotalNodesInPath]);            soundLibrary.addLibSound(null, j+"", Language);        }        for (var i=0; i < 40; i++){            soundLibrary.addLibSound(ESoundType.FeedbackClick, i, Language);        }        soundLibrary.addLibSound(ESoundType.FeedbackClick, "Bubble");    }		//Este método permite actualizar la meta. Tiene sentido para el caso de bubble ChangePlus al momento de llevar a cabo la segunda pregunta		public function updateCurrentGoal(newGoal : Number)        {			gameGoal.currentGoal = newGoal;		}        public function setupEndAnimation(pIndex : int, pStage : Stage) : GameComponent        {            var munequito : GameComponent = createAndPositionMc(Util.getRandomFrom(characters) as String,  mPiecesList[pIndex].x - 30, mPiecesList[pIndex].y - 100);            game.world.addChild(munequito);            var speechBubble : GameComponent = createAndPositionMc("SpeechBubble",  mPiecesList[pIndex].x - 30, mPiecesList[pIndex].y - 100);            speechBubble.numeral = _mNodes[pIndex].numeral;            colorPiece(speechBubble, EColor.BlueGray);            game.world.addChild(speechBubble);            var counter : Counter = new Counter(ENumberForm.Numeral, _mNodes[pIndex].numeral, pStage)            game.world.addChild(counter);            counter.x = _mPiecesList[pIndex].x;            counter.y = _mPiecesList[pIndex].y;            counter.scaleX = counter.scaleY = 0.7;            Util.removeChild(_mPiecesList[pIndex].mAnimationList_Mc[2]);            //gc.addChild(gc.Movie);            //gc.animate("tube");            Util.bringToFront(munequito);            //mPiecesList[pIndex].addChild(gc);            soundLibrary.playLibSound(null, _mNodes[pIndex].numeral, Language);            Util.debug("G5.endAnimation.addCharacterAndVoice.if " + _mNodes[pIndex].numeral );            return munequito;        }    function createG5C(pMovieName : String, pX : Number = 0,  pY : Number = 0, pAlpha : Number = 100)    {        var sea : GameComponent = new GameComponent();        sea.MovieName = pMovieName;        sea.x = pX;        sea.y = pY;        sea.alpha = pAlpha;        game.addChild(sea);    }    public function chooseSkin () : int    {        Util.debug("G5.initializeG5Background" + paramsList[mpNumTotalNodesInPath] + " " + G5Lib.MAX_NUM_ROAD_1)        if(paramsList[mpNumTotalNodesInPath] < MAX_NUM_ROAD_1)            return MAX_NUM_ROAD_1;        else if (paramsList[mpNumTotalNodesInPath] < MAX_NUM_ROAD_2)            return MAX_NUM_ROAD_2;        else if (paramsList[mpNumTotalNodesInPath] < MAX_NUM_ROAD_3)            return MAX_NUM_ROAD_3;        throw "no possible world!"    }    public function get mPiecesList():Array {        return _mPiecesList;    }    public function set mPiecesList(value:Array):void {        _mPiecesList = value;    }    public function get mHoles():Array {        return _mHoles;    }    public function set mHoles(value:Array):void {        _mHoles = value;    }    public function get mAnswerBoxCounters():Array {        return _mAnswerBoxCounters;    }    public function set mAnswerBoxCounters(value:Array):void {        _mAnswerBoxCounters = value;    }    public function get mNodes():Array {        return _mNodes;    }    public function set mNodes(value:Array):void {        _mNodes = value;    }    public function get mAnimatingNodes():Array {        return _mAnimatingNodes;    }    public function set mAnimatingNodes(value:Array):void {        _mAnimatingNodes = value;    }}}