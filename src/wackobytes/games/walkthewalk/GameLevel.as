package com.kpm.games.walkthewalk {	  import com.kpm.util.*;    public class GameLevel {    private var mGoals: Array;    private var mInvDetermined: Array;    private var mTotalObjects: Array;    private var mGoalObjPos: Array;    private var mNumRounds: Number;    private var mNumGoalObjects: Array;    static public const TOTALGCS_RANDOM: Number = 0;    static public const TOTALGCS_FIXEDATMAX: Number = 1;    static public const TOTALGCS_SAMEASGOALOBJS: Number = 2;    static public const TOTALGCS_ATLEASTONEPLUSGOALS: Number = 3;        static public var MAX_TOTAL_OBJECTS = 15; // Can provide get/set methods to alter    static public var MIN_TOTAL_OBJECTS = 2;    static public var MIN_GOAL_OBJECTS = 1;    static public var MAX_GOAL_OBJECTS = 3;    static public var MIDDLE_VALUE = 0;    private var mMinTotalObjects: Number;    private var mMaxTotalObjects: Number;    public function GameLevel(pNumGoalsByRound: Array, pInvariants: Array, pNumRounds: Number,                              pMaxGoals: Number, pTotalCharactersType: Number){      mNumRounds = pNumRounds;      mMinTotalObjects = MIN_TOTAL_OBJECTS;      mMaxTotalObjects = MAX_TOTAL_OBJECTS;      mGoals = new Array();      mInvDetermined = new Array();      mTotalObjects = new Array();      mGoalObjPos = new Array();      mNumGoalObjects = new Array();      var i: Number;      var j: Number;      var k: Number;	        for(i = 0; i < mNumRounds; i++){        mGoals[i] = new Array();        mInvDetermined[i] = new Array();        mGoalObjPos[i] = new Array();        do {          mNumGoalObjects[i] = generateNumGoalObjectsPerRound(pMaxGoals);                  } while(i > 0 && mNumGoalObjects[i] == mNumGoalObjects[i - 1]); // Prevents same # of goal objects                                                                        // in consecutive rounds        mTotalObjects[i] = generateNumTotalObjectsPerRound(mNumGoalObjects[i], pTotalCharactersType);        var vQuesRepeated: Boolean; // This can become a parameter in case repetitions are allowed        do {          vQuesRepeated = false;          for(j = 0; j < CharacterQuality.NUM_QUALITIES; j++){            mGoals[i][j] = new Array();            // If a certain # of goals is desired for quality #j, then a disjunctive list of quality ids is created            for(k = 0; k < pNumGoalsByRound[i][j]; k++){              while(true){                mGoals[i][j][k] = CharacterQuality.getRandomQuality(j);                var l: Number = 0;                for(; l < k; l++)                  if(mGoals[i][j][k] == mGoals[i][j][l]) break;                if(l >= k) break;              }            }            if(pInvariants[i][j]){              if(pNumGoalsByRound[i][j] > 0)                mInvDetermined[i][j] = mGoals[i][j][0];              else if(pInvariants[i][j] < 0)                mInvDetermined[i][j] = Math.abs(pInvariants[i][j]);              else                mInvDetermined[i][j] = CharacterQuality.getRandomQuality(j);            }            else              mInvDetermined[i][j] = -1;          }          // Find out if the question generated is a repeat of the previous one          if(i > 0){			var p : uint = UniformGameLevelSpec.RepeatGoal            for(j = 0; j < CharacterQuality.NUM_QUALITIES; j++){              for(k = 0; k < mGoals[i][j].length; k++)              {              	if(i >= p)              	{              	 if(mGoals[i][j][k] != mGoals[i - p][j][k])                  	break; // This, of course, recognizes "red or blue" as different from "blue or red"                         // but the definition of a repetition for disjunctive lists needs to be supplied first,                         // i.e. the linguistic aspects of wording such questions may be a factor in itself.               }                 else                 	break;              }              if(k < mGoals[i][j].length)                break;            }            if(j >= CharacterQuality.NUM_QUALITIES)              vQuesRepeated = true;          }        } while(vQuesRepeated);		        // Now, generate the positions for the goal objects to appear - an implicit consideration is        // that the position of the targets (goals) should be randomized within the list and not form a        // contiguous group.		          for(j = 0; j < mNumGoalObjects[i]; j++){          while(true){            mGoalObjPos[i][j] = Math.floor(Math.random() * mTotalObjects[i]);            for(k = 0; k < j; k++)              if(mGoalObjPos[i][j] == mGoalObjPos[i][k]) break;            if(k >= j) break;          }        }        mGoalObjPos[i].sort();      }    }//    private function generateNumGoalObjectsPerRound(pMaxGoals: Number): Number {////      return 1 + Math.floor(Math.random() * pMaxGoals);//    }    private function generateNumGoalObjectsPerRound(pMaxGoals: Number): Number {    			Util.debug("GameLevel.generateNumGoalObjectsPerRound " + pMaxGoals);    	var maxGoals : Number ;     	    		    	if(pMaxGoals != 0)    	{    		Util.debug("generating numbers " + pMaxGoals);    		return 1 + Math.floor(Math.random() * pMaxGoals);    	}    	else    	{    		if(GameLevel.MAX_GOAL_OBJECTS < GameLevel.MAX_TOTAL_OBJECTS)    			maxGoals = GameLevel.MAX_GOAL_OBJECTS    		else	    			maxGoals = GameLevel.MAX_TOTAL_OBJECTS;    	    		Util.debug("generating number " + GameLevel.MIN_GOAL_OBJECTS + " " + GameLevel.MIDDLE_VALUE + " " + maxGoals);    	 	var enumberArray = GameLib.generateENumbers(GameLevel.MIN_GOAL_OBJECTS, GameLevel.MIDDLE_VALUE, maxGoals);		  	var goal : ENumber = Util.getRandomFrom(enumberArray) as ENumber;		  	//Util.debug("generating number " + goal.Text);		  	return goal.Text;    	}	    }        private function generateNumTotalObjectsPerRound(pNumGoals: Number, pTotalCharactersType: Number): Number {      switch(pTotalCharactersType){        case TOTALGCS_RANDOM: return generateTotalNumObjectsBetweenMaxMin(pNumGoals);        case TOTALGCS_FIXEDATMAX: return mMaxTotalObjects;        case TOTALGCS_SAMEASGOALOBJS: return pNumGoals;        case TOTALGCS_ATLEASTONEPLUSGOALS:                   var vTotalNum: Number = generateTotalNumObjectsBetweenMaxMin(pNumGoals);                   return (vTotalNum > pNumGoals) ? vTotalNum : pNumGoals + 1;        default: if(pTotalCharactersType < 0)                   return pNumGoals + Math.abs(pTotalCharactersType);                 else                   return pNumGoals;      }      return pNumGoals;    }    private function generateTotalNumObjectsBetweenMaxMin(pNumGoals: Number): Number {      var vMinNum: Number = 0;      if(mMinTotalObjects - pNumGoals > 0)        vMinNum = mMinTotalObjects - pNumGoals;      var vMoreNum: Number = mMaxTotalObjects - pNumGoals;      if(vMoreNum < 0) vMoreNum = 0;      if(vMoreNum > mMaxTotalObjects - mMinTotalObjects)        vMoreNum = mMaxTotalObjects - mMinTotalObjects;      return pNumGoals + vMinNum + Math.floor(Math.random() * (vMoreNum + 1));    }    public function get Goals (): Array {      return mGoals;    }    public function get Invariants (): Array {      return mInvDetermined;    }    public function get TotalObjects (): Array {      return mTotalObjects;    }    public function get GoalObjPos (): Array {      return mGoalObjPos;    }    public function get NumRounds (): Number {      return mNumRounds;    }    public function get NumGoalObjects (): Array {      return mNumGoalObjects;    }  }}