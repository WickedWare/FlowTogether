package com.kpm.util{	import com.kpm.kpm.KpmBubble;		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.FileListEvent;	import flash.events.IOErrorEvent;	import flash.filesystem.*;	import flash.net.FileReference;	import flash.net.Socket;import flash.system.Capabilities;import flash.utils.ByteArray;	//	import com.alivepdf.colors.RGBColor;//	import com.alivepdf.fonts.CodePage;//	import com.alivepdf.fonts.EmbeddedFont;//	import com.alivepdf.layout.Orientation;//	import com.alivepdf.layout.Size;//	import com.alivepdf.layout.Unit;//	import com.alivepdf.pdf.PDF;//	import com.alivepdf.saving.Method;œ			public class KpmIO extends EventDispatcher	{		[Embed( source="/data/pdfassets/myriad.ttf", mimeType="application/octet-stream" )]		private var fontStream:Class;		[Embed( source="/data/pdfassets/myriad.afm", mimeType="application/octet-stream" )]		private var afmStream:Class;				public static var READ_COMPLETE : String = "READ_COMPLETE";		public static var READ_ERROR : String = "READ_ERROR";		public static var DIR_LIST_COMPLETE : String = "DIR_LIST_COMPLETE";				public static var DEFAULT_LOCATION : File = File.applicationStorageDirectory;				var defaultLocation : File;				var fileContents 	: String;																//AIR		var fileStream		: FileStream;																//AIR		var mErrorMessage	: String;						public var readContents : String;		public var mFile 		: File;		public var mFileList	: Array;						public function KpmIO()		{            if(Capabilities.manufacturer.indexOf("iOS")!= -1)            {                Util.debug("Changing Default Location");                DEFAULT_LOCATION = File.documentsDirectory;            }		}						public function setFilePath(pPath : String, location : String = null)		{						try			{				if(!location)					defaultLocation = DEFAULT_LOCATION;				else if (location == "desktop")					defaultLocation = File.desktopDirectory;				else if(location == "app-storage:/")					defaultLocation = File.applicationStorageDirectory;				else if(location == "app")					defaultLocation = File.applicationDirectory;				else if(location == "documents")					defaultLocation = File.documentsDirectory;									mFile = defaultLocation.resolvePath(pPath);								if(fileStream != null)																					fileStream.close();																								fileStream = new FileStream();								}			catch ( e : Error)			{				Util.debug("could not find file " + pPath, this);			}										Util.debug("file set with " + mFile.url, this);		}				public function read() : void		{			Util.debug("KpmIO.read");			fileStream.openAsync(mFile, FileMode.READ);			fileStream.addEventListener(Event.COMPLETE, processRead, false, 0 , true);			fileStream.addEventListener(IOErrorEvent.IO_ERROR, readError, false, 0 , true);		}				function processRead(event:Event) : void 		{			Util.debug("pedossssss reading" + mFile.url, this);    		readContents = fileStream.readUTFBytes(fileStream.bytesAvailable);    		this.dispatchEvent(new Event(KpmIO.READ_COMPLETE));    		    		fileStream.close();		}				function readError(e:Event): void		{			this.dispatchEvent(new Event(KpmIO.READ_ERROR));			Util.debug("read Error from " + mFile.url, this);		}		public function write(pWriteObject : *, pOverwrite : Boolean = true)		{			if(!fileStream)					return;						if(pOverwrite)				fileStream.open(mFile, FileMode.WRITE);			else				fileStream.open(mFile, FileMode.APPEND);															mErrorMessage = "Could not append for a new session.";								fileStream.addEventListener(IOErrorEvent.IO_ERROR, writeError, false, 0 , true);			Util.debug("writing...", this);						if(pWriteObject is XML){								fileStream.writeUTFBytes("\n" + pWriteObject.toXMLString());				Util.debug(pWriteObject.toXMLString(), this);			}			else { 				fileStream.writeUTFBytes(pWriteObject);				Util.debug(pWriteObject, this);			}																			fileStream.close();		}				public function writePdf(pWriteObject : *)		{//				//           var p:PDF = new PDF( Orientation.PORTRAIT, Unit.MM, Size.A4 );//			var ef:EmbeddedFont = new EmbeddedFont( new fontStream(), new afmStream(), CodePage.CP1252 );//////			p.setFont( ef, 10 );//			p.addPage();			//			p.textStyle( new RGBColor(0x000099), 1 );//			p.writeText(12, pWriteObject);//			//			var bytes:ByteArray = p.save( Method.LOCAL );//			write(bytes);		}				public function exists () : Boolean		{			return mFile.exists;		}		public static function existsInStorage(pPath : String) : Boolean		{			var file : File;			file = KpmIO.DEFAULT_LOCATION.resolvePath(pPath);						if(file.exists)				return true;			else 				return false;		}				public static function deleteFromStorage(pPath : String)		{			var file : File;			if(KpmIO.existsInStorage(pPath))			{				file = KpmIO.DEFAULT_LOCATION.resolvePath(pPath);				file.deleteDirectory(true);			}		}				public static function copyToAsync(pFrom : *, pTo : KpmIO, handler : Function, errorHandler : Function = null, pMove : Boolean = false, pOverwrite : Boolean = true) 		{			Util.debug("copying from " + pFrom, KpmIO);						if(pFrom is KpmIO)				pFrom = pFrom.mFile;							if(pMove)				pFrom.moveToAsync(pTo.mFile, pOverwrite);			else				pFrom.copyToAsync(pTo.mFile, pOverwrite);								pFrom.addEventListener(Event.COMPLETE, handler, false, 0 , true);						if(errorHandler != null)				pFrom.addEventListener(IOErrorEvent.IO_ERROR, errorHandler, false, 0 , true);		}				public static function copyIntoAsync(pFrom : *, pTo : KpmIO, handler : Function, errorHandler : Function = null, pMove : Boolean = false, pOverwrite : Boolean = true) 		{			Util.debug("KpmIO.copyIntoAsync : copying from " + pFrom + " into " + pTo, KpmIO);						if(pFrom is KpmIO)				pFrom = pFrom.mFile;							var directory:Array = pFrom.getDirectoryListing();			    	for each (var f:File in directory)	    	{	    		Util.debug("KpmIO.copyInto" + f.name);				if(pMove)					f.moveToAsync(pTo.mFile, pOverwrite);				else					f.copyToAsync(pTo.mFile, pOverwrite);		    	}		}				public static function copyFileReference(pFileRef : FileReference, pPath : String)		{			var tmpFile: KpmIO =  new KpmIO();			tmpFile.setFilePath(pPath);			tmpFile.write(pFileRef.data);		}				function writeError(e:Event):void													//AIR		{																					//AIR			Util.debug("Write Error from: " + mErrorMessage, this);									//AIR		}							public function listDirectory():void {						mFile.addEventListener(FileListEvent.DIRECTORY_LISTING, dirListHandler);			mFile.getDirectoryListingAsync();		 		}			function dirListHandler(event:FileListEvent):void {			var contents = event.files;			var cFile:File;			mFileList = new Array();						for (var i = 0; i < contents.length; i++) {				cFile = contents[i] as File;		 		mFileList.push(cFile.url);				}						this.dispatchEvent(new Event(KpmIO.DIR_LIST_COMPLETE));					}				public static function openFile(pPath : String, pLoc : String)		{			var file : KpmIO = new KpmIO();			file.setFilePath(pPath, pLoc);			file.mFile.openWithDefaultApplication();		}				public static function createDirectory(pString : String, pLoc : String) 		{			var file : KpmIO = new KpmIO();			file.setFilePath(pString, pLoc);			file.mFile.createDirectory();					}				public function deleteFile()		{			mFile.deleteDirectory(true);		}        public static function documentsURL ()        {            return File.documentsDirectory.url;        }	}}