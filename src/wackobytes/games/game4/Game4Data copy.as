package com.kpm.games.game4 {	import com.kpm.util.*;	import com.kpm.kpm.BubbleId;	import com.kpm.kpm.EBName;	import com.kpm.kpm.EBStd;	import com.kpm.kpm.KpmBubble;  	public class Game4Data extends GameLib{	public var playerKind 				: int ;	public var numAnchorsPerPlatform	: uint = 5;	public var lvl_Indoors				: Boolean = false;	public var lvl_OrganizedObjects		: Boolean ;	public var lvl_Organization			: String;	public var lvl_DifferentObjects		: Boolean;	public var lvl_CountDifferentSizes	: int;	public var lvl_CountGroups			: int;	public var maxNumGoals				: int;	public var maxNumNonGoals			: int;	public const LEFTALIGN_BRANCH 		: String = "LEFTALIGN_BRANCH";	public const CENTERALIGN_SIDE		: String = "CENTERALIGN_SIDE";	public const DISORGANIZED_BRANCH	: String = "DISORGANIZED_BRANCH";	public const DISORGANIZED_SIDE		: String = "DISORGANIZED_SIDE";	public const DISORGANIZED_TOTALLY	: String = "DISORGANIZED_TOTALLY";	//Las tres variables siguientes son utilizadas sólo para el caso de la bubble Comparison	public var groups : Array;	public const PLATFORM_SEPARATION: Array = new Array( 1, 180, 70);    public const PLATFORM_TOP: Array = new Array( 1, 150, 70);			        public function Game4Data(bId : BubbleId, pLanguage : ELanguage, pGame : Object){		super(bId, pLanguage, pGame);		defineBubbleVars();          }        //Actualiza variables para cada bubble usando el quality, Bubble.Name y Bubble.Level    private function defineBubbleVars(){		//Define gameGoal. Used for logging purposes.		super.updateGoal();		trace("GOAL: " + gameGoal.quality);		if(gameGoal.quality == EGoal.COUNT){			gameGoal.numOptions = 5 ;			gameGoal.numCorrectOptions = 1;			maxNumGoals = EBName.countNumber(Bubble.Name);						//Bubble Vars for Count bubbles			if(Bubble.Name.Text.indexOf("Subset") == -1){				maxNumNonGoals = 0;				switch(Bubble.Level){					case 1:						lvl_DifferentScales = false; //Same sizes						lvl_DifferentColors = false; //Same colors						lvl_OrganizedObjects = true; //Organized != Characters randomly placed						break;   					case 2:						lvl_DifferentScales = false; //Same sizes						lvl_DifferentColors = true;  //Different colors  						lvl_OrganizedObjects = true; //Organized						break; 					case 3:						lvl_DifferentScales = true;   //Different sizes						lvl_DifferentColors = false;  //Same colors						lvl_OrganizedObjects = false; //Characters randomly placed						break;    					case 4:						lvl_DifferentScales = true;   //Different sizes						lvl_DifferentColors = true;   //Different colors						lvl_OrganizedObjects = false; //Characters randomly placed						break;				}			}			//Bubble Vars for Subset Bubbles			else if(Bubble.Name.Text.indexOf("Subset") != -1){				//maxNumNonGoals = 0.5*maxNumGoals;				maxNumGoals = EBName.countNumber(Bubble.Name);				if(maxNumGoals <= 10){					maxNumNonGoals = maxNumGoals-1;					switch(Bubble.Level){						case 1:							lvl_OrganizedObjects = true;       //Organized != Characters randomly placed							lvl_DifferentScales = false;       //Same sizes							lvl_DifferentColors = false;       //Same colors							gameGoal.subquality = EGoal.COLOR; //Answer depends on color							break;						case 2:							lvl_OrganizedObjects = true;       //Organized							lvl_DifferentScales = false;       //Same sizes							lvl_DifferentColors = false;       //Same colors							gameGoal.subquality = EGoal.SIZE;  //Answer depends on size							break;						case 3:							lvl_OrganizedObjects = false;      //Characters randomly placed							lvl_DifferentScales = true;        //Different sizes							lvl_DifferentColors = false;       //Same colors							gameGoal.subquality = EGoal.COLOR; //Answer depends on color							break;    						case 4:							lvl_OrganizedObjects = false;     //Characters randomly placed							lvl_DifferentScales = true;       //Same sizes							lvl_DifferentColors = true;       //Different colors							gameGoal.subquality = EGoal.SIZE; //Answer depends on size					}				}				else if(maxNumGoals > 10){					maxNumNonGoals = Math.round(0.5 * maxNumGoals);					switch(Bubble.Level){						case 1:							lvl_OrganizedObjects = false;      //Characters randomly placed							lvl_DifferentScales = true;        //Different sizes							lvl_DifferentColors = false;       //Same colors							gameGoal.subquality = EGoal.COLOR;  //Answer depends on color							break;						case 2:							lvl_OrganizedObjects = false;      //Characters randomly placed							lvl_DifferentScales = true;        //Different sizes							//lvl_DifferentColors = false;     //Different colors							lvl_DifferentColors = true;							gameGoal.subquality = EGoal.SIZE; //Answer depends on size					}				}	   		}		}		if (gameGoal.quality == EGoal.ADDITION) {			maxNumGoals = EBName.countNumber(Bubble.Name);						gameGoal.numOptions = maxNumGoals > 3 ? 5 : 3;			gameGoal.numCorrectOptions = 1;						//Acá se setean los valores para la bubble ChangePlus#			lvl_OrganizedObjects = true;			lvl_DifferentScales = false;			if (Bubble.Name.Text.indexOf("ChangePlus1") != -1) {				switch(Bubble.Level) {					case 1: lvl_Indoors = false;		 //Entran en la casa recién despues de responder bien la pregunta							lvl_DifferentColors = false; //Both groups are same color							break;					case 2: lvl_Indoors = false;		//Entran en la casa recién despues de responder bien la pregunta							lvl_DifferentColors = true; //Both groups are different color							break;					case 3: lvl_Indoors = true;			//Entran en la casa  antes de responder la pregunta							lvl_DifferentColors = true; //Both groups are different color							break;					case 4: lvl_Indoors = true;			 //Entran en la casa  antes de responder la pregunta							lvl_DifferentColors = false; //Both groups are same color							break;				}			}			if (Bubble.Name.Text.indexOf("ChangePlus2") != -1) {				switch(Bubble.Level) {					case 1: lvl_Indoors = false;		 //Entran en la casa recién despues de responder bien la pregunta							lvl_DifferentColors = false; //Both groups are same color							break;					case 2: lvl_Indoors = false;		//Entran en la casa recién despues de responder bien la pregunta							lvl_DifferentColors = true; //Both groups are different color							break;					case 3: lvl_Indoors = true;			//Entran en la casa  antes de responder la pregunta							lvl_DifferentColors = true; //Both groups are different color							break;					case 4: lvl_Indoors = true;			 //Entran en la casa  antes de responder la pregunta							lvl_DifferentColors = false; //Both groups are same color							break;				}			}			if (Bubble.Name.Text.indexOf("ChangePlusU") != -1) {				switch(Bubble.Level) {					case 1: lvl_Indoors = false;		 //Entran en la casa recién despues de responder bien la pregunta							lvl_DifferentColors = false; //Both groups are same color							break;					case 2: lvl_Indoors = false;		//Entran en la casa recién despues de responder bien la pregunta							lvl_DifferentColors = true; //Both groups are different color							break;					case 3: lvl_Indoors = true;			//Entran en la casa  antes de responder la pregunta							lvl_DifferentColors = true; //Both groups are different color							break;					case 4: lvl_Indoors = true;			 //Entran en la casa  antes de responder la pregunta							lvl_DifferentColors = false; //Both groups are same color							break;				}			}		}		if (gameGoal.quality == EGoal.COMPARISON) {						if (Bubble.Name.Text.indexOf("CompareEstimate") != -1) {				lvl_CountGroups = 2;				lvl_Organization = DISORGANIZED_SIDE;				switch(Bubble.Level) {					case 1: lvl_CountDifferentSizes = 1;							break;					case 2: lvl_CountDifferentSizes = 2;							break;					case 3: lvl_CountDifferentSizes = 3;							break;				}			}			if (Bubble.Name.Text.indexOf("CompareCorrespond") != -1){				lvl_CountGroups = 2;				lvl_Organization = LEFTALIGN_BRANCH;				switch(Bubble.Level) {					case 1: lvl_CountDifferentSizes = 1;							break;					case 2: lvl_CountDifferentSizes = 2;							break;					case 3: lvl_CountDifferentSizes = 3;							break;				}			}			if (Bubble.Name.Text.indexOf("Compare3Correspond") != -1) {				lvl_CountGroups = 3;				lvl_Organization = LEFTALIGN_BRANCH;				switch(Bubble.Level) {					case 1: lvl_CountDifferentSizes = 1;							break;					case 2: lvl_CountDifferentSizes = 2;							break;					case 3: lvl_CountDifferentSizes = 3;							break;				}			}			if (Bubble.Name.Text.indexOf("CompareCount") != -1){				lvl_CountGroups = 2;				lvl_Organization = CENTERALIGN_SIDE;				switch(Bubble.Level) {					case 1: lvl_CountDifferentSizes = 1;							break;					case 2: lvl_CountDifferentSizes = 2;							break;					case 3: lvl_CountDifferentSizes = 3;							break;				}			}			if (Bubble.Name.Text.indexOf("CompareDisorganized") != -1){				lvl_CountGroups = 2;				lvl_Organization = DISORGANIZED_SIDE;				switch(Bubble.Level) {					case 1: lvl_CountDifferentSizes = 1;							break;					case 2: lvl_CountDifferentSizes = 2;							break;					case 3: lvl_CountDifferentSizes = 3;							break;				}			}			if (Bubble.Name.Text.indexOf("Compare3Disorganized") != -1) {				lvl_CountGroups = 3;				lvl_Organization = DISORGANIZED_BRANCH;				switch(Bubble.Level) {					case 1: lvl_CountDifferentSizes = 1;							break;					case 2: lvl_CountDifferentSizes = 2;							break;					case 3: lvl_CountDifferentSizes = 3;							break;				}			}			if (Bubble.Name.Text.indexOf("CompareMixed") != -1) {				lvl_CountGroups = 2;				lvl_Organization = DISORGANIZED_TOTALLY;				switch(Bubble.Level) {					case 1: lvl_CountDifferentSizes = 1;							break;					case 2: lvl_CountDifferentSizes = 2;							break;					case 3: lvl_CountDifferentSizes = 3;							break;				}			}			if (Bubble.Name.Text.indexOf("Compare3Mixed") != -1) {				lvl_CountGroups = 3;				lvl_Organization = DISORGANIZED_TOTALLY;				switch(Bubble.Level) {					case 1: lvl_CountDifferentSizes = 1;						break;					case 2: lvl_CountDifferentSizes = 2;						break;					case 3: lvl_CountDifferentSizes = 3;						break;				}			}						gameGoal.numOptions = lvl_CountGroups;			gameGoal.numCorrectOptions = 1;		}	}		//$ update the variables that change per task.		public function updateTaskVars(){			var i=0;						do			{				switch (gameGoal.quality) {					case EGoal.COUNT: 	 CurrentGoal = (Bubble.Name.Text.indexOf("Subset") == -1)? generateCountGoal() : generateSubsetGoal();										 break;					case EGoal.ADDITION: CurrentGoal =  generateChangePlusGoal(Bubble.Name.Text.split("_")[0]); //Si tengo ChangePlus1_3 entonces mando como parametro ChangePlus										 break;					case EGoal.COMPARISON: CurrentGoal = generateComparisonGoal(Bubble.Name.Text.split("_")[0]);				}				i++;								Util.debug("generated current goal" + gameGoal.currentGoal);			}			while (gameGoal.currentGoal == gameGoal.pastGoal && i < 10);						//gameGoal.currentGoalText = CharQual.NUMBER_NAMES[gameGoal.currentGoal];			gameGoal.pastGoal = gameGoal.currentGoal;			//*starts a task/round			startTask(gameGoal.numOptions, gameGoal.numCorrectOptions);		}		//Generate the number of goals (Count Bubble)		public function generateCountGoal() : Number{			trace("generateBigCountGoal ");			switch(maxNumGoals){				//1-5 (33% chance) 6-10 (66% chance)				case 3 : return Util.getRandBtw(1, 3);				case 5 : if (Math.random() <= .66){							return Util.getRandBtw(4, 5);						  }						  else {							 return Util.getRandBtw(1, 3);						  }				case 7 : if (Math.random() <= .66){							return Util.getRandBtw(6, 7);						  }						  else {							  return Util.getRandBtw(1, 5);						  }				case 10 : if (Math.random() <= .66){							return Util.getRandBtw(6, 10);						  }						  else {							  return Util.getRandBtw(1, 5);						  }				case 15 : return Util.getRandBtw(10, 15);				case 20 : return Util.getRandBtw(10, 20);			}			throw new Error("generateBigCoungGoal maxnumgoals " + maxNumGoals);			return -1;		}		//Generate the number of goals (Subset Bubble)		public function generateSubsetGoal() : Number{			trace("generateBigSubsetGoal ");			switch(maxNumGoals){				//1-5 (33% chance) 6-10 (66% chance)				case 3 : return Util.getRandBtw(1, 3);				case 5 : if (Math.random() <= .66){							return Util.getRandBtw(4, 5);						  }						  else {							 return Util.getRandBtw(1, 3);						  }				case 7 : if (Math.random() <= .66){							return Util.getRandBtw(6, 7);						  }						  else {							  return Util.getRandBtw(1, 5);						  }				case 10 : if (Math.random() <= .66){							return Util.getRandBtw(6, 10);						  }						  else {							  return Util.getRandBtw(1, 5);						  }				case 15 : return Util.getRandBtw(1, 15);				case 20 : return Util.getRandBtw(1, 20);			}			throw new Error("generateBigCoungGoal maxnumgoals " + maxNumGoals);			return -1;		}		public function generateChangePlusGoal(subnameBubble : String) : Number {			trace("generateAdditionGoal " + subnameBubble + maxNumGoals);			var aux : Number = Math.random();			if (subnameBubble == "ChangePlusU")				return 5; //El código importante en cuanto a los porcentajes para los distintos esquemas va en Game4.as			else {				switch(maxNumGoals){					//1-5 (33% chance) 6-10 (66% chance)					case 3  : return (Util.getRandBtw(1, 2));					case 4  : if (subnameBubble == "ChangePlus1")								return (Util.getRandBtw(0, 1) ? Util.getRandBtw(1, 2) : 3);							  else return Util.getRandBtw(1, 2); //Este seria el caso de ChangePlus2					case 5  : if (subnameBubble == "ChangePlus1")								return (Util.getRandBtw(0, 1) ? Util.getRandBtw(1, 3) : 4);							  else return (Util.getRandBtw(0, 1) == 0) ? Util.getRandBtw(1, 2) : 3; //Este seria el caso de ChangePlus2					case 7  : if (aux <= .33) return Util.getRandBtw(1, 3);							  else {									if (aux > .33 && aux <= .66) return Util.getRandBtw(4,5);									else return 6;								}					case 10 : if (aux <= .10)								return 4;							 else {									if (aux > .10 && aux <= .40) return Util.getRandBtw(5, 6);									else return Util.getRandBtw(7, 9);							 }							 break;				}			}			return -1;		}		public function generateComparisonGoal(bubbleName : String) : Number {			groups = new Array();						maxNumGoals = EBName.countNumber(Bubble.Name);						Util.debug("Game4Data.generateComparisonGoal maxNumGoals " + maxNumGoals);						switch (bubbleName) {				case "CompareEstimate": 					switch (maxNumGoals)					{						case 3 : 	groups.push(Util.getRandBtw(1, 3));								 	groups.push(Util.getRandBtw(Math.ceil(groups[0] * 3 / 2), 10));								 	break;									 						case 5 : 	groups.push(Util.getRandBtw(1, 5));									groups.push(Util.getRandBtw(Math.ceil(groups[0] * 3 / 2), 15));		 									break;									 						case 10 : 	groups.push(Util.getRandBtw(3, 10));								 	groups.push(Util.getRandBtw(Math.ceil(groups[0] * 3 / 2), 20));									break;						}					break;					case "CompareCorrespond": 					switch (maxNumGoals)					{						case 5 : 	setGroupsValues(1, 5, 2); 									break;						case 10 : 	setGroupsValues(1, 10, 2);									break;					}					break;				case "Compare3Correspond":					switch (maxNumGoals)					{						case 5 : 	setGroupsValues(1, 5, 2); 							break;						case 10 : 	setGroupsValues(1, 10, 2);							break;					}					break;									case "CompareCount":					switch (maxNumGoals)					{						case 5 : 	setGroupsValues(1, 5, 2); 							break;						case 10 : 	setGroupsValues(1, 10, 2);							break;					}					break;				//				case "CompareCount": groups.push(Util.getRandBtw(1, 10));//									 groups.push(Util.getRandBtw(Math.ceil(groups[0] * 3 / 2), 15));//									 break;				case "CompareDisorganized": 					switch (maxNumGoals)					{						case 5 : 	setGroupsValues(2, 4, 2); 							break;						case 10 : 	setGroupsValues(3, 10, 2);							break;						case 15 : 	setGroupsValues(5, 15, 2);							break;											}					break;								case "Compare3Disorganized": 					switch (maxNumGoals)					{						case 5 : 	setGroupsValues(2, 4, 2); 							break;						case 10 : 	setGroupsValues(3, 10, 2);							break;						case 15 : 	setGroupsValues(5, 15, 2);							break;											}					break;				case "CompareMixed": 					switch (maxNumGoals)					{						case 5 : 	setGroupsValues(1, 5, 2); 							break;						case 10 : 	setGroupsValues(1, 10, 2);							break;						case 15 : 	setGroupsValues(1, 15, 2);							break;					}					break;								case "Compare3Mixed": 					switch (maxNumGoals)					{						case 5 : 	setGroupsValues(1, 5, 2); 							break;						case 10 : 	setGroupsValues(1, 10, 2);							break;					}					break;								default: trace("No valid bubble");			}						Util.debug("Printing array groups");			Util.printArray(groups);						return Math.max.apply(null,groups);//Se retorna el mayor elemento		}		//Este método setea la cardinalidad de los grupos X, Y, Z para las bubbles Comparison		private function setGroupsValues(min : int, max : int, delta : int) {			var i : int = 1;			var value : int;			groups[0] = Util.getRandBtw(min, max);			while (i < lvl_CountGroups) {				value = Util.getRandBtw(groups[i-1] - delta, groups[i-1] + delta);				//Si el valor no fue utilizado aún				if ((groups.indexOf(value) == -1) && (value <= max) && (value > 0)) {					groups.push(value);					i++;				}			}		}		/*		//Se setea la cardinalidad de los grupos X y Y		private function set2GroupValues() {			groupX = Util.getRandBtw(1, 10);			groupY = Util.getRandBtw(groupX - 2, groupX + 2);			while ((groupY < 1) || (groupY > 10) || (groupX == groupY)) {				groupY = Util.getRandBtw(groupX - 2, groupX + 2);			}		}		//Se setea la cardinalidad de los grupos X, Y y Z		private function set3GroupValues() {			groupX = Util.getRandBtw(1, 10);			groupY = Util.getRandBtw(groupX - 2, groupX + 2);			while ((groupY < 1) || (groupY > 10) || (groupX == groupY)) {				groupY = Util.getRandBtw(groupX - 2, groupX+ 2);			 }			groupZ = Util.getRandBtw(groupY - 2, groupY + 2);			 while ((groupZ < 1) || (groupZ > 10) || (groupY == groupZ) || (groupX == groupZ)) {				groupZ = Util.getRandBtw(groupZ - 2, groupZ + 2);			}		}*/		//Retorna el mayor número de una terna. Se utiliza en el caso de las bubble Comparison para setear el CurrentGoal		/*private function largestGroup(x : int, y : int, z : int = -1) : int {			if (x > y && x > z) return x;			if (y > x && y > z) return y;			if (z > x && z > y) return z;			return -1; //No debería pasar nunca.		}*/				//Este método permite actualizar la meta. Tiene sentido para el caso de bubble ChangePlus al momento de llevar a cabo la segunda pregunta		public function updateCurrentGoal(newGoal : Number) {			gameGoal.currentGoal = newGoal;		}	}}