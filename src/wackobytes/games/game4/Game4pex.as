package com.kpm.games.game4{	import com.kpm.util.*;	import com.kpm.games.EGameCharacter;	import com.kpm.games.walkthewalk.GCMovement;	import com.kpm.kpm.BubbleId;	import com.kpm.kpm.EBName;		import flash.display.DisplayObject;	import flash.display.MovieClip;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.sampler.NewObjectSample;	import flash.text.TextField;	import flash.utils.Timer;	import flash.utils.getDefinitionByName;	public class Game4 extends Game{		//*current bubble being played		private var mBubbleId : BubbleId;		//*default language		private const DEFAULT_LANGUAGE: String = "SPA";		//*whether music is muted or not		private var mMute: Boolean;		//*Music		private var mMusic: Sound;		private var mMusicChannel: SoundChannel;		//*Sound & Text message		protected var mQuestionMessage	: Game4Message;		protected var mWelcomeMessage	: Game4Message;		protected var mStatusMessage	: Game4Message;		protected var mLookMoreMessage	: Game4Message;		//Index for player species or kind (1 for monkey 2 for bird)		private var mPlayerKind : int;		//corresponding word for the player kind		private var mPlayerWord : String;		//$branches/wires		private var platforms : Game4Platforms;		//$2d array of points where monkeys/birds can be		private var board : Array = new Array();		//*birds and monkeys need to go to the house in addition bubble		private var house : GameComponent ;		private var endAnimation_mc : MovieClip;		//*monkeys/birds		private var mGameCharacters: Array;		//* array to store counters		private var mGameCounters: Array;		//$ array to store character movements		private var mGCMove: Array;		//*Game play information that depends on the player kind		public const COUNTERS_POS: Array = new Array( 1, new Point2D(1215,80), new Point2D(1215,40));		public const COUNTERS_HEIGHT : int = 155;		private var subquality : String = "";				private var distractorCharacters : Array;		private var timer : Timer;		//Esta variable es para que el sonido "AndNow" no lo ejecute la primera vez, y si lo haga una de cada tres veces.		private var cantExecutions : uint;		private var cantCharactersToMove : uint;		//private var idCounterGoal : uint;		private var speedArray : Array;		private var changePlusUScheme   : Array;//Definido como un caso particular debido a su falta de uniformidad		private var changePlusScheme    : Array;//Es el esquema generado por breakUpCurrentGoal		private var firsGroupColor      : Number;		private var firstQuestion       : Boolean = true;//Definido para determinar si hay que proceder con la segunda pregunta o ya se ha respondido bien está (onCounterClick)		private var timerSecondQuestion : Timer;//Este timer es para retrasar la ejecución de la segunta pregunta		private var timerLookMessage : Timer;//Este timer es para retrasar la ejecución de la pregunta intermedia (lookXMoreMessage)		private var timerMoveFirstGroup : Timer;				private var movingFirsGroup		: Boolean;		private var secondQuestion		: Boolean = false;		private var characterHouse: MovieClip;		private var teasingDone : Boolean;				private var changePlusString : String;				public function Game4() {}				//Function called from G4.fla on first frame, it initializes Bubble to be played, character to be played,		//and the Data object and starts the game		public function initGame (pBubbleId : BubbleId = null, pLanguage: ELanguage = null, pPlayerTheme : EGameCharacter = null){			//Util.debug("Game4.initGame");			cantExecutions = 1;			timer = new Timer(2000,1);			timer.addEventListener(TimerEvent.TIMER_COMPLETE, removeGameCharacters, false, 0 , true);			//Se usan para el caso de la bubble ChangePlus. Para retrasar la ejecución de la segunda pregunta			timerSecondQuestion = new Timer(3500,1);			timerSecondQuestion.addEventListener(TimerEvent.TIMER_COMPLETE, makeSecondQuestion, false, 0 , true);			//Se usan para el caso de la bubble ChangePlus. Para retrasar la ejecución de la pregunta intermedia (poseIntermediateMessage)			timerLookMessage = new Timer(500,1);			timerLookMessage.addEventListener(TimerEvent.TIMER_COMPLETE, lookXMoreMessage, false, 0 , true);			//Define player kind (monkey or bird)			if(pPlayerTheme == null)			 	mPlayerKind = CharQual.BIRD;			else if (pPlayerTheme == EGameCharacter.Monkey)				mPlayerKind = CharQual.MONKEY;			else if (pPlayerTheme == EGameCharacter.Bird)				mPlayerKind = CharQual.BIRD;			//mPlayerKind = CharQual.BIRD; //SOLO PARA TESTING			mPlayerWord = CharQual.SPECIES_NAMES[mPlayerKind];						//Initialize bubble id			if(pBubbleId == null)				 mBubbleId = new BubbleId(EBName.CompareEstimate, 2);				 //mBubbleId = new BubbleId(EBName.CountFinger_10, 4);				 //mBubbleId = new BubbleId(EBName.CountDiceDots_10,3);				 //mBubbleId = new BubbleId(EBName.Count5Frame_15,1);				 //mBubbleId = new BubbleId(EBName.Subset5Frame_5,1);				 //mBubbleId = new BubbleId(EBName.Count5Frame_5, 2);				 //mBubbleId = new BubbleId(EBName.ChangePlus1_4, 1);				 //mBubbleId = new BubbleId(EBName.ChangePlus1_4, 3);				//mBubbleId = new BubbleId(EBName.ChangePlus1_10, 3);				 //mBubbleId = new BubbleId(EBName.Subset5Frame_20, 2);				 //mBubbleId = new BubbleId(EBName.ChangePlus2_5, 3);//tiene problema a veces				 //mBubbleId = new BubbleId(EBName.ChangePlusU_5, 3);//tiene problema a veces				//mBubbleId = new BubbleId(EBName.ChangePlusU_5, 3);			else mBubbleId = pBubbleId;			//initialize GameData : which is the interface with the Driver			if(pLanguage == null)				pLanguage = ELanguage.ENG;			mData = new Game4Data(mBubbleId, pLanguage, this);			mGCMove = new Array();			startGame();		}		//Se definen los esquemas según las especificaciones para ChangePlusU		private function initChangePlusUScheme() {			changePlusUScheme = new Array();			changePlusUScheme[0] = [[1, 1], [2, 1], [3, 1]];			changePlusUScheme[1] = [[4, 1], [1, 2], [2, 2], [3,2]];			changePlusUScheme[2] = [[1, 3], [2, 3], [1, 4]];		}		//Este método crear la monkeyHouse o la birdHouse según sea el caso		private function createHouse() {			switch (mPlayerKind) {				case CharQual.MONKEY: this.addChild((characterHouse = Util.createMc("monkeyHouse")));									  characterHouse.x = 566.75;									  characterHouse.y = 145.00;									  break;				case CharQual.BIRD:   this.addChild((characterHouse = Util.createMc("birdHouse")));									  characterHouse.x = 640.05;									  characterHouse.y = 590.05;									  break;			}						addChild(tQuestionText);			addChild(tStatusText);		}		//Este método inicializa una matriz de velocidades para que los characters tengan velocidades variables.		private function initSpeedArray() {			//0 --> Left-side and 1 --> Right-side 			speedArray = new Array(0, 1);			speedArray[0] = new Array(0, 1, 2);			speedArray[1] = new Array(0, 1, 2);			speedArray[0][0] = 23;			speedArray[0][1] = 23;			speedArray[0][2] = 23;			speedArray[1][0] = 23;			speedArray[1][1] = 23;			speedArray[1][2] = 23;		}		private function startGame(event: Event = null) {			//no music for now			//G4Data.initializeMusic();			changePlusString = (mBubbleId.Name.Text.indexOf("ChangePlus") != -1) ? "house" : "";						//Esto se hace para dejar que flash renderise todos los elementos del stage y luego inicializar plataformas y demas			this.gotoAndStop("background" + mPlayerWord + changePlusString)			stage.addEventListener( Event.RENDER, populatePlatforms, false, 0, true );			stage.invalidate();		}		//$populate platforms (branches, wires)		//store col points in board (2d array)		public function populatePlatforms(e : Event){			Util.debug("Game4.PopulatePlatforms" + this.currentLabel + " " + mPlayerWord)			stage.removeEventListener( Event.RENDER, populatePlatforms);						platforms = new Game4Platforms();			platforms.addPlatform(this[mPlayerWord + "P0" + changePlusString], 0);			platforms.addPlatform(this[mPlayerWord + "P1" + changePlusString], 1);			platforms.addPlatform(this[mPlayerWord + "P2" + changePlusString], 2);			tInteractionPanel.visible = true;			if (mBubbleId.Name.Text.indexOf("ChangePlus") != -1){				initChangePlusUScheme();				if ((mData as Game4Data).lvl_Indoors)					createHouse();			}			startRound();		}		public override function initializeAudio() : KpmSound		{			Util.debug("Game4.createMusic");			if(mPlayerKind == CharQual.MONKEY)				return G4Data.createSound("backgroundMusicmonkey", 1, 1, true, false, true);			else				return G4Data.createSound("backgroundMusicbird", 1, 0.2, true, false, true);					}				//* mute music		public function mute(pMute: Boolean = false){				G4Data.mute()		}		//$Start round/task		private function startRound(event: Event = null) {			//Util.debug("Game4.startRound");			G4Data.updateTaskVars();			initSpeedArray();			//setup players			populateGC();		}		//$Set counters		//give answer + 4 distractors (distractors should be within 3 of range)		//example : if answer is 21, possible distractors are 18 - 24		function setupCounters(currentGoal : Number){			removeCounters();			//var numArray  : Array = Util.generateConsecutiveNumbersAround(G4Data.gameGoal.currentGoal as Number, G4Data.maxNumGoals);			var numArray  : Array = Util.generateConsecutiveNumbersAround(currentGoal, G4Data.maxNumGoals);			mGameCounters = new Array(numArray.length);			//Util.debug("counters : ");			Util.printArray(numArray);			for (var i=0; i < numArray.length; i++){				//Create counter				//Util.debug("create counter " + i + " " + numArray);				mGameCounters[i] = new Counter(Counter.getNumberForm(mBubbleId), numArray[i], stage); 				//add mouse click event listener				mGameCounters[i].x = COUNTERS_POS[mPlayerKind].x;				mGameCounters[i].y = COUNTERS_POS[mPlayerKind].y + i*COUNTERS_HEIGHT;				if(mGameCounters[i].form == ENumberForm.FiveFrame)				{					mGameCounters[i].scaleX *= 1.2;					mGameCounters[i].scaleY *= 1.2;				}				//add child to the movieclips displayed in game					addChild(mGameCounters[i]);			}			addCounterEvents(true);		}		//*Add or remove events for counter		private function addCounterEvents (pAdd : Boolean) {			for(var i: Number = 0; i < mGameCounters.length; i++){				if(mGameCounters[i] != null){					if(pAdd){						EventManager.addEvent(mGameCounters[i], MouseEvent.CLICK, onCounterClick, i);						//Change the cursor to 'hand cursor' when mouse is over 						mGameCounters[i].buttonMode = true;						if(GameLib.driver) CursorManager.addOverEvents(mGameCounters[i]);					}					else {						EventManager.removeEvent(mGameCounters[i], MouseEvent.CLICK);						mGameCounters[i].buttonMode = false;						if(GameLib.driver) CursorManager.removeOverEvents(mGameCounters[i]);					}				}			}		}		//Suit the characters (monkeys or birds) in their positions		private function suitCharacters(characters : Array, i : uint = 0) {			disableCounters(characters.length);			var finX: Number;			var finY: Number;			for(i; i < characters.length; i++){				//Se guardan los valores de la posicion en la cual cada monkey debe ser colocado				finX = characters[i].x;				finY = characters[i].y;				//En funcion de la posicion en la grilla en la que debe ser colocado el monkey, 				//se crea una nueva posicion desde la cual el monkey se desplace hasta su posicion final				if (characters[i].Coord.x < 5){					characters[i].PixelPosition = platforms.coordsToPixels(new Point2D(0,characters[i].Coord.y));					//Esta correccion es para evitar un ciclo infinito cuando la posicion final					//y la posicion de partida son iguales					characters[i].x = characters[i].x - 80;				}				else {					characters[i].PixelPosition = platforms.coordsToPixels(new Point2D(9,characters[i].Coord.y));					characters[i].x = characters[i].x + 80;				}								Util.debug("suit characters " + finX + " " + finY);				//Aca se lleva a cabo el movimiento				moveGCTo(i, new Point2D(finX,finY));				characters[i].animate("moveLeft");			}		}		//$Populate GameCharcters (GC : Monkeys/Birds) 		public function populateGC(){			if (!mGameCharacters)				populateGC_Continuation();		}		//Este método remueve los characters distractores (si es que existen) e inicia un timer que luego provoca que se ejecute el método removeGameCharacters.		private function removeDistractorCharacter() {			platforms.initPlayersBoard();			//Pregunto porque puede tratarde de una bubble que no es Subset			if(distractorCharacters){				//Util.debug("Game4.removeDistractorCharacter");				for(var i=0; i < distractorCharacters.length; i++){					Util.removeChild(distractorCharacters[i]);				}			}			timer.start();		}		//Remove all game characters from the game		public function removeGameCharacters(e : Event){			if(G4Data.gameGoal.taskCounter < G4Data.gameGoal.totalTasks){				//Util.debug("removing characters");	 			for(var i=0; i < mGameCharacters.length; i++){					Util.removeChild(mGameCharacters[i]);				}				//Util.debug("populating more characters");				populateGC_Continuation();			}		}		//Si se trata de las bubbles Count y Subset desde acá se inician. Creando sus characters, etc.		//Si se trata de la bubble ChangePlus, entonces se da inicio con los pasos correspondiente a la primer pregunta: crear el primer grupo de characters, etc.		private function populateGC_Continuation() {			mGameCharacters = new Array();			var randomColor : Boolean = G4Data.lvl_DifferentColors;			var randomSize  : Boolean = G4Data.lvl_DifferentScales;			var putInOrden  : Boolean = G4Data.lvl_OrganizedObjects;			if (mBubbleId.Name.Text.indexOf("ChangePlus") == -1) {				//Esto es para el caso de las bubbles Count y Subset				//Util.debug("creating gc " + G4Data.gameGoal.currentGoal);				createGCatBranch(randomColor, randomSize, G4Data.gameGoal.currentGoal as Number, putInOrden);				setupCounters(G4Data.gameGoal.currentGoal as Number);				suitCharacters(mGameCharacters);				cantExecutions++;			}			else {				//Este es el caso de la bubble ChangePlus				//Esto es para indicar cuando se debe realizar la segunda pregunta. Se usa en arriveAt				secondQuestion = false;				//Significa que una nueva task para la bubble ChangePlus ha comenzado				firstQuestion = true;				//Se genera y se guarda en la variable global el esquema de la bubble ChangePlus según corresponda a la especificación				changePlusScheme = breakUpCurrentGoal(G4Data.gameGoal.currentGoal as Number);				//Se crea el primer grupo de characters				putGroupChangePlus(true);				//Para el caso de ChangePlus1 y ChangePlus2 sería igual llamar con G4Data.gameGoal.currentGoal as Number. 				//El problema es con ChangePlusU, que recién se sabe el valor en Game4 y no en Game4Data.				setupCounters(changePlusScheme[0]);				//Se posicionan los characters, haciendolos caminar/volar. Acá es el primer grupo de characters				suitCharacters(mGameCharacters);			}		}		//Crea los characteres de un grupo (firstGroup o no).		private function putGroupChangePlus(firstGroup : Boolean) {			//Define a color and a default size			var currColor : Number;			var currSize  : Number = 0;			var position : Point2D;			var cantCharacters : uint;			if (firstGroup){				 //Si entra acá es porque recién va a entrar el primer grupo				 currColor = Util.getRandomFrom(CharQual.VALID_COLORS[mPlayerKind]) as Number;				 firsGroupColor = currColor;				 cantCharacters = changePlusScheme[0];			}			else {				//Me fijo si hay que usar diferentes colores (en función de lo especificado en Game4Data). De ser así genero uno distinto al usado				//en el primer grupo. Caso contrario uso el del primer grupo.				if ((mData as Game4Data).lvl_DifferentColors) {					var colors : Array = generateDistinctColors(2, 4);					var aux : uint = 0;					var encontre : Boolean = false;					while ((aux < colors.length) && (!encontre)) {						if ((firsGroupColor != (colors[aux]))){							currColor = colors[aux];							encontre = true;						}						aux++;					}				}				else currColor = firsGroupColor;				cantCharacters = changePlusScheme[1];			}			for(var i=0; i < cantCharacters; i++){				if (firstGroup){					if (i < 5) 						 position =  new Point2D(i, 0);					else position =  new Point2D(i - 5, 1);				}				else position =  new Point2D(9 - i, 0);				Util.debug("POSICION GENERADA AL MOMENTO DE LA CREACIÓN. X = " + position.x + " - Y = " + position.y);				var gc : Game4Player = createGC(currColor, currSize, position);				addChild(gc);				mGameCharacters.push(gc);			}		}		//This function return true if color is not present in colors		private function isDifferentColor(color : Number, colors : Array) : Boolean {			var i : int = 0;			while (i < colors.length) {				if (color == colors[i])					return false;				i++;			}			return true;		}		//This function return true if size is not present in sizes		private function isDifferentSize(size : Number, sizes : Array) : Boolean {			var i : int = 0;			while (i < sizes.length) {				if (size == sizes[i])					return false;				i++;			}			return true;		}		//Esta función genera un arreglo de colores distintos. La cantidad es mayor igual que min y menos igual que max.		private function generateDistinctColors(min : int, max : int) : Array {			var colors : Array = new Array();			var color : Number			//Generate up to [min,max] different colors			var cantColors : int = Util.getRandBtw(min, max);			for (var i : int = 0; i < cantColors; i++) {				color = Util.getRandomFrom(CharQual.VALID_COLORS[mPlayerKind]) as Number;				while (!isDifferentColor(color, colors)) {					color = Util.getRandomFrom(CharQual.VALID_COLORS[mPlayerKind]) as Number;				}				colors.push(color);			}			return colors;		}		//Esta función genera un arreglo de tamaños distintos. La cantidad es mayor igual que min y menos igual que max.		private function generateDistinctSizes(min : int, max : int) : Array {			var sizes : Array = new Array();			//Generate up to [min,max] different sizes			var cantSizes : int = Util.getRandBtw(min, max);			for (var i : int = 0; i < cantSizes; i++) {				var size : Number = Util.getRandBtw(0, CharQual.SIZE_VALUES.length - 1) as Number;				while (!isDifferentSize(size,sizes)) {					var size : Number = Util.getRandBtw(0, CharQual.SIZE_VALUES.length - 1) as Number;				}				sizes.push(size);			}			return sizes;		}		//Retorna el esquema segun el cual se deben disponer los characters en el escenario, segun cual sea la bubble.		//Además, si se trata de ChangePlusU entonces actualiza el gameGoal.currenGoal		private function breakUpCurrentGoal(goal : int) : Array {			var scheme : Array = new Array;			if (mBubbleId.Name.Text.indexOf("ChangePlus") == -1) {				//El caso de Subset y Count				var aux : int = Util.getRandBtw(1, Math.floor(goal / 2));				scheme.push(aux);				if (goal - aux > 15){ //Si quedan más de 15 characters en un lado del escenario entonces hay que reacomodar el esquema					scheme.push(15);  //Lleno uno de los lados					scheme[0] = goal - 15; //y ajusto el otro lado con los characters que "sobran" del primer lado.				}				else scheme.push(goal - aux); //Si no se supera el límite de 15 characters por lado, entonces simplemente asigno la cantidad.				if ((mBubbleId.Name.Text.indexOf("Count") != -1) && (mBubbleId.Level == 1) && ((EBName.countNumber(mBubbleId.Name) == 15)) || (EBName.countNumber(mBubbleId.Name) == 20)) {					//Se ajusta el breakUp para que sólo una rama tenga menos de 5 characters.					scheme[0] = ((Math.floor(goal / 5) * 5) > 15)? 15 : (Math.floor(goal / 5) * 5);					scheme[1] = goal - scheme[0];					if (scheme[1] == 0) {						scheme[0] = scheme[0] - 5;						scheme[1] = scheme[1] + 5;					}				}			}			else {				//El caso de ChangePlus#				switch(mBubbleId.Name.Text.split("_")[0]) {					case "ChangePlus1": 							scheme[0] = goal; 							scheme[1] = 1;							break;					case "ChangePlus2":							scheme[0] = goal;							scheme[1] = 2;							break;					case "ChangePlusU":							var prob : Number = Math.random();							if (prob <= .15) scheme = changePlusUScheme[0][Util.getRandBtw(0, changePlusUScheme[0].length - 1)];							if (prob > .15 && prob <= 0.55) scheme = changePlusUScheme[1][Util.getRandBtw(0, changePlusUScheme[1].length - 1)];							if (prob > .55) scheme = changePlusUScheme[2][Util.getRandBtw(0, changePlusUScheme[2].length - 1)];							(mData as Game4Data).updateCurrentGoal(scheme[0]);							break;				}			}			return scheme;		}		//$create numGC monkeys with different properties		//pColor : index defined in CharQual.VALID_COLORS, -1 means random color, 		//pSize : index defined in CharQual.SIZE_VALUES, -1 means random size		//level : -1 means random level		//col : -1 means random col 		public function createGCatBranch( randomColor : Boolean, randomSize : Boolean, numGC : int = 1, putInOrder : Boolean = true) {			var colors : Array = new Array();			var sizes  : Array = new Array();			//If the bubble is Count*			if (mBubbleId.Name.Text.indexOf("Count") != -1){				if (randomColor) 					 colors = generateDistinctColors(2, 3);				else colors.push(Util.getRandomFrom(CharQual.VALID_COLORS[mPlayerKind]) as Number);				if (randomSize)					 sizes = generateDistinctSizes(2, 2);				else sizes.push(Util.getRandBtw(0, CharQual.SIZE_VALUES.length - 1) as Number);				if (putInOrder)					 putCharactersInOrder_CountBubble(numGC, colors, sizes);				else putCharactersAtRandom_CountBubble(numGC, colors, sizes);			}			else {	if (mBubbleId.Name.Text.indexOf("Subset") != -1){						//If the bubble is Subset*						//In this case randomColor means different colors. Idem to randomSize.						colors = generateDistinctColors(4, 4);						sizes  = generateDistinctSizes(2, 2);						subquality = ((mData as Game4Data).gameGoal.subquality == EGoal.COLOR)? CharQual.COLOR_NAMES[colors[0]] : CharQual.SIZE_NAMES[sizes[0] + 1];						if (putInOrder)							 putCharactersInOrder_SubsetBubble(numGC, colors, sizes, randomColor, randomSize);						else putCharactersAtRandom_SubsetBubble(numGC, colors, sizes, randomColor, randomSize);					}			}		}		//Este método crea los characters correspondientes al branch izquierdo para el caso de la bubble Count		private function fillLeftBranch_CountBubble(cantCharacters : int, charactersByBranch : int, upsideDown : Boolean, currColor : Number, currSize : Number, colors : Array, sizes : Array) {					var branch : int = (upsideDown)? 2 : 0;			var pos : int = 0;			var i: int;			//Rest one because the matrix (platform) starts at zero			for (i = 0; i <= cantCharacters-1; i++) {				if ((i!=0) && (i%charactersByBranch) == 0){					pos = 0;					branch = (upsideDown)? branch - 1 : branch +1;				}				//If color will be different for all monkeys				if(colors.length != 1) 					currColor = colors[Util.getRandBtw(0,colors.length-1)]; 				if(sizes.length != 1) 					currSize = sizes[Util.getRandBtw(0, sizes.length - 1)];				var position : Point2D =  new Point2D(pos, branch);				var gc : Game4Player				gc = createGC(currColor, currSize, position);				addChild(gc);				mGameCharacters.push(gc);				pos++;			}		}		//Este método crea los characters correspondientes al branch derecho para el caso de la bubble Count		private function fillRightBranch_CountBubble(cantCharacters: int, charactersByBranch : int, upsideDown : Boolean, currColor : Number, currSize : Number, colors : Array, sizes : Array) {			var branch : int = (upsideDown)? 2 : 0;			//Last position in the right side			var pos : int = 9;			for (var i = 0; i <= cantCharacters-1; i++) {				if ((i!=0) && (i%charactersByBranch) == 0){					pos = 9;					branch = (upsideDown)? branch - 1 : branch +1;				}				//If color will be different for all monkeys				if(colors.length != 1) 					currColor = colors[Util.getRandBtw(0,colors.length-1)]; 				if(sizes.length != 1) 					currSize = sizes[Util.getRandBtw(0, sizes.length - 1)];				var position : Point2D =  new Point2D(pos, branch);				var gc : Game4Player = createGC(currColor, currSize, position);				addChild(gc);				mGameCharacters.push(gc);				pos--;			}		}		//This function puts the monkeys/birds in some order (Count Bubble)		private function putCharactersInOrder_CountBubble(currentGoal : int, colors : Array, sizes : Array){			//Choose one of the possibilities: (2+9) or (3+8) or ...			var randomScheme : Array = breakUpCurrentGoal(currentGoal);			var cantLeft : int;			var cantRight: int;			//Si se trata de Subset o Count se le agrega un grado de incertidumbre a la cantidad de characters en cada lado del escenario			//Choose how many monkeys/birds put in left side and how many in right side, of random manner			var aux : int = Util.getRandBtw(0, 1);			cantLeft = randomScheme[aux];			cantRight = randomScheme[(aux + 1) % 2];			//Is determined at random where to start: up or down			var upsideDown : Boolean = Util.getRandBtw(0, 1) == 0;			//Determine the number of monkeys / birds can be in each branch			var charactersByBranch : int = platforms.NumCols / 2;			//Define a color and a default size			var currColor : Number = (colors.length == 1)? colors[0] : colors[Util.getRandBtw(0,colors.length-1)];			var currSize : Number = (sizes.length == 1)? sizes[0] : sizes[Util.getRandBtw(0, sizes.length)];			//Util.debug("left right " + cantLeft + " " + cantRight + " " + currentGoal);			fillLeftBranch_CountBubble(cantLeft,charactersByBranch,upsideDown,currColor,currSize,colors,sizes);			fillRightBranch_CountBubble(cantRight,charactersByBranch,upsideDown,currColor,currSize,colors,sizes);		}		//Este método crea los characters correspondientes al branch izquierdo para el caso de la bubble Subset		private function fillLeftBranch_SubsetBubble(cantCharacters : int, distractorsCharactersProperties : Array, charactersByBranch : int, upsideDown : Boolean, colors : Array, sizes : Array, distinctColors : Boolean, distinctSizes : Boolean) {			var branch : int = (upsideDown)? 2 : 0;			var pos : int = 0;			var i: int = 0;			var distractorIndex : int = 0;			var putGoalMonkey : Boolean;			var cantCharacterGoalColocated : int = 0;			//Define a color and a default size			var currColor : Number;			var currSize  : Number;			//Rest one because the matrix (platform) starts at zero			while (i < cantCharacters + (distractorsCharactersProperties.length / 2)) {				if (distractorIndex >= distractorsCharactersProperties.length)					 putGoalMonkey = true;				else putGoalMonkey = (Util.getRandBtw(0, 1) == 0 && cantCharacterGoalColocated < cantCharacters);				if ((i!=0) && (i%charactersByBranch) == 0){						pos = 0;						branch = (upsideDown)? branch - 1 : branch +1;				}				if (putGoalMonkey){					if ((mData as Game4Data).gameGoal.subquality == EGoal.SIZE){						if (distinctColors){							 currColor = Util.getRandomFrom(CharQual.VALID_COLORS[mPlayerKind]) as Number;						}						else {							currColor = colors[0];							currSize  = sizes[0];						}					}					else {						if (distinctSizes)							 currSize = sizes[Util.getRandBtw(0, sizes.length - 1)];						else {							currColor = colors[0];							currSize  = sizes[0];						}					}					cantCharacterGoalColocated++;				}				else {					currColor = distractorsCharactersProperties[distractorIndex];					currSize = distractorsCharactersProperties[distractorIndex + 1];					distractorIndex = distractorIndex + 2;				}				var position : Point2D =  new Point2D(pos, branch);				var gc : Game4Player				gc = createGC(currColor, currSize, position);				addChild(gc);				mGameCharacters.push(gc);				if (!putGoalMonkey)					distractorCharacters.push(gc);				pos++;				i++;			}		}		//Este método crea los characters correspondientes al branch derecho para el caso de la bubble Subset		private function fillRightBranch_SubsetBubble(cantCharacters: int, distractorsCharactersProperties : Array, charactersByBranch : int, upsideDown : Boolean, colors : Array, sizes : Array, distinctColors : Boolean, distinctSizes : Boolean) {			var branch : int = (upsideDown)? 2 : 0;			//Last position in the right side			var pos : int = 9;			var i: int = 0;			var distractorIndex : int = 0;			var putGoalMonkey : Boolean;			var cantCharacterGoalColocated : int = 0;			//Define a color and a default size			var currColor : Number;			var currSize  : Number;			while (i < cantCharacters + (distractorsCharactersProperties.length / 2)) {				if (distractorIndex >= distractorsCharactersProperties.length)					 putGoalMonkey = true;				else putGoalMonkey = (Util.getRandBtw(0, 1) == 0 && cantCharacterGoalColocated < cantCharacters);				if ((i!=0) && (i%charactersByBranch) == 0){						pos = 9;						branch = (upsideDown)? branch - 1 : branch +1;				}				if (putGoalMonkey){					if ((mData as Game4Data).gameGoal.subquality == EGoal.SIZE){						if (distinctColors){							 currColor = Util.getRandomFrom(CharQual.VALID_COLORS[mPlayerKind]) as Number;						}						else {							currColor = colors[0];							currSize  = sizes[0];						}					}					else {						if (distinctSizes)							 currSize = sizes[Util.getRandBtw(0, sizes.length - 1)];						else {							currColor = colors[0];							currSize  = sizes[0];						}					}					cantCharacterGoalColocated++;				}				else {					currColor = distractorsCharactersProperties[distractorIndex];					currSize = distractorsCharactersProperties[distractorIndex + 1];					distractorIndex = distractorIndex + 2;				}				var position : Point2D =  new Point2D(pos, branch);				var gc : Game4Player = createGC(currColor, currSize, position);				addChild(gc);				mGameCharacters.push(gc);				if (!putGoalMonkey)					distractorCharacters.push(gc);				pos--;				i++;			}		}		//This function puts the monkeys/birds in some order (Subset Bubble)		private function putCharactersInOrder_SubsetBubble(currentGoal : int, colors : Array, sizes : Array, distinctColors : Boolean, distinctSizes : Boolean){			var distractorsCharactersProperties : Array = generateDistractors(currentGoal, colors, sizes, distinctColors, distinctSizes);						//Choose one of the possibilities: (2+9) or (3+8) or ...			var randomScheme : Array = breakUpCurrentGoal(currentGoal);			var cantLeft : int;			var cantRight: int;			//Si se trata de Subset o Count se le agrega un grado de incertidumbre a la cantidad de characters en cada lado del escenario			//Choose how many monkeys/birds put in left side and how many in right side, of random manner			var aux : int = Util.getRandBtw(0, 1);			cantLeft = randomScheme[aux];			cantRight = randomScheme[(aux + 1) % 2];			//Is determined at random where to start: up or down			var upsideDown : Boolean = Util.getRandBtw(0, 1) == 0;			//Determine the number of monkeys / birds can be in each branch			var charactersByBranch : int = platforms.NumCols / 2;			//Start in one to include at least one element			var cut : int = Util.getRandBtw(1, (distractorsCharactersProperties.length/2) - 1);			distractorCharacters = new Array();			fillLeftBranch_SubsetBubble(cantLeft, distractorsCharactersProperties.slice(0,cut*2),charactersByBranch, upsideDown, colors, sizes, distinctColors, distinctSizes);			fillRightBranch_SubsetBubble(cantRight, distractorsCharactersProperties.slice(cut*2,distractorsCharactersProperties.length),charactersByBranch, upsideDown, colors, sizes, distinctColors, distinctSizes);		}		//This function puts the monkeys/birds in random places (Count Bubble) 		private function putCharactersAtRandom_CountBubble(currentGoal : int, colors : Array, sizes : Array) {			//Define a color and a default size			var currColor : Number = Util.getRandomFrom(CharQual.VALID_COLORS[mPlayerKind]) as Number;			var currSize  : Number = Util.getRandBtw(0, CharQual.SIZE_VALUES.length-1) as Number; 			for(var i=0; i < currentGoal; i++){					//If color will be different for all monkeys				if(colors.length != 1) 					currColor = colors[Util.getRandBtw(0,colors.length-1)]; 				if(sizes.length != 1) 					currSize = sizes[Util.getRandBtw(0, sizes.length - 1)];				//The parameters -1 and -1 means random position				var position : Point2D = platforms.getRandomEmptyPlace(-1, -1);				var gc : Game4Player = createGC(currColor, currSize, position);				addChild(gc);				mGameCharacters.push(gc);			}		}		//This function puts the monkeys/birds in random places (Subset Bubble)		private function putCharactersAtRandom_SubsetBubble(currentGoal : int, colors : Array, sizes : Array, distinctColors : Boolean, distinctSizes : Boolean) {			//Define a color and a default size			var currColor : Number = colors[0];			var currSize  : Number = sizes[0];			var distractorsCharactersProperties : Array = generateDistractors(currentGoal, colors, sizes, distinctColors, distinctSizes);			//Guarda los caracteres distractores para poder ser eliminados cuando se responde bien una pregunta.			distractorCharacters = new Array();			for(var i=0; i < currentGoal; i++){				if ((mData as Game4Data).gameGoal.subquality == EGoal.SIZE){					if (distinctColors){						currColor = Util.getRandomFrom(CharQual.VALID_COLORS[mPlayerKind]) as Number;					}				}				else {					if (distinctSizes)						currSize = sizes[Util.getRandBtw(0, sizes.length - 1)];				}				var position : Point2D = platforms.getRandomEmptyPlace(-1, -1);				var gc : Game4Player = createGC(currColor, currSize, position);				addChild(gc);				mGameCharacters.push(gc);			}			for (var i = 0; i < distractorsCharactersProperties.length; i = i + 2) {				var position : Point2D = platforms.getRandomEmptyPlace(-1, -1);				//distractorsCharactersProperties in even index is equal to 'color'.				//distractorsCharactersProperties in odd index is equal to 'size'.				var gc : Game4Player = createGC(distractorsCharactersProperties[i], distractorsCharactersProperties[i+1], position);				addChild(gc);				mGameCharacters.push(gc);				distractorCharacters.push(gc);			}		}		//Retorna un color contenido en availableColors y que no esta en usedColors		private function selectDistinctColor(usedColors : Array, availableColors : Array) : Number {			var nColor : Number;			nColor = availableColors[Util.getRandBtw(1, availableColors.length - 1)];			while (!isDifferentColor(nColor, usedColors)) {				nColor = availableColors[Util.getRandBtw(1, availableColors.length - 1)];			}			return nColor;		}		//Esta función genera un arreglo con propiedades que van a tener los distintos grupos distractores. Dicho arreglo es usado por otro método para		//efectivamente crear los characters correspondientes a los distintos grupos y siguiendo las propiedades dadas (color, size, etc)		private function generateDistractors(currentGoal : int, colors : Array, sizes : Array, distinctColors : Boolean, distinctSizes : Boolean) : Array {			var charactersInGroup : int;			var currentObjects : int = currentGoal;			var maxNumObjects : int = currentGoal + (mData as Game4Data).maxNumNonGoals;			var numGroups : int = 0;			var dColor, dSize : Number;			var usedColors : Array = new Array();			var distractorsCharactersProperties : Array = new Array();			//colors[0] is the color used by the goal			usedColors.push(colors[0]);			if ((mData as Game4Data).gameGoal.subquality == EGoal.SIZE) {				dSize = sizes[1];				dColor = colors[0];			}			else {				dSize = sizes[0];				dColor = colors[Util.getRandBtw(1, colors.length - 1)];			}			do {				//Amount of characters in the distractor group				charactersInGroup = Util.getRandBtw(1, maxNumObjects - currentObjects);				if ((mData as Game4Data).gameGoal.subquality == EGoal.SIZE){					if (distinctColors){						dColor = selectDistinctColor(usedColors, colors);						usedColors.push(dColor);					}				}				else{					if (distinctColors) {						dColor = selectDistinctColor(usedColors, colors);						usedColors.push(dColor);					}					if (distinctSizes)						dSize = (dSize == sizes[0])? sizes[1] : sizes[0];				}				for (var i = 0; i < charactersInGroup; i++) {					distractorsCharactersProperties.push(dColor);					distractorsCharactersProperties.push(dSize);				}				currentObjects = currentObjects + charactersInGroup;				numGroups++			}while ((numGroups < 3)	&& (currentObjects < maxNumObjects));			return distractorsCharactersProperties;		}		//$Create GC with a defined color, size, and position (level and col)		public function createGC(pColor : Number, pSize : Number, pPosition : Point2D) : Game4Player{			//Util.debug("creating "+  mPlayerWord + " " +  pPosition + " color " + pColor + " size " + pSize);			var gc : Game4Player = new Game4Player(mPlayerKind, pColor);			gc.Size = pSize;			gc.Coord = pPosition;			gc.PixelPosition = platforms.coordsToPixels(pPosition);			gc.Speed = speedArray[(pPosition.x < 5)?0 : 1][pPosition.y] - Util.getRandBtw(1,3);						//gc.PixelPosition = this.tilesToPixel(gc.Tile);			//this defines this space as occupied			platforms.addCharacter(gc, gc.Coord);			return gc;		}		//Este metodo hace mover los characters hacia la house		private function moveCharactersToHouse(i : uint,gotoInitSecondQuestion : Boolean) {			//tengo en cuenta que si hay mas de 5 monkeys ademas se van a tener que hacer algunos jump			//el firstQuestion es porque el segundo grupo no tiene mas de 5 monkeys			Util.debug("Game4.moveCharactersToHouse " + (mGameCharacters.length - i))			if ((mPlayerKind == CharQual.MONKEY) && (firstQuestion) && (mGameCharacters.length > 5))				 disableCounters(mGameCharacters.length - i + (mGameCharacters.length % 5));				 			else disableCounters(mGameCharacters.length - i);//Para el caso de la segundo grupo nunca hay mas de 5 character así que simplemente caminan. Y para las aves no importa, simplemente vueltan						var housePosition : Point2D = new Point2D(characterHouse.x, characterHouse.y);			var newPosition   : Point2D;			Util.debug("INDICE INICIAL: " + i);			for(i; i < mGameCharacters.length; i++){				if ((mPlayerKind == CharQual.MONKEY) && (mGameCharacters[i].Coord.y  == 1)) {					//En este caso es necesario primero hacer que el monkey baje de rama (saltando) y luego se dirija hacia la house					newPosition = platforms.coordsToPixels(new Point2D(mGameCharacters[i].Coord.x, 0));					//Aca se lleva a cabo el movimiento					moveGCTo(i, newPosition, false,true, housePosition);					mGameCharacters[i].animate("jump");				}				else {					//Acá estoy en el caso de los birds, con lo cual sin importar en la rama en la que se encuentren pueden volar hacia cualquier posición					mGameCharacters[i].Speed = 23 - Util.getRandBtw(1,4);					if(firstQuestion && mPlayerKind == CharQual.BIRD)						moveGCTo(i, new Point2D(housePosition.x - 100, housePosition.y - 20), true);					else						moveGCTo(i, housePosition, true);					mGameCharacters[i].animate("moveLeft");				}			}			/*if (gotoInitSecondQuestion){				var timerInitSecondQuestion : Timer = new Timer(3000,1);				timerInitSecondQuestion.addEventListener(TimerEvent.TIMER_COMPLETE, initSecondQuestion);				timerInitSecondQuestion.start();			}*/		}		//$Function triggered when the user clicks on counter		private function onCounterClick (event: MouseEvent, pCounterId: Number) {			//Set cursor to normal			CursorManager.setIdleCursor(null);			Util.debug("clicked " + mGameCounters[pCounterId] + " " + mGameCounters[pCounterId].number + " " +  G4Data.gameGoal.currentGoal);			//* It is necessary to save the time at first click and save a string that identifies what was clicked			//(green, 5, big, 2)			G4Data.FirstMove = 0;			G4Data.gameGoal.currentMove = mGameCounters[pCounterId].number +"";			//if the counter is correct, 			//remove all counters except the correct one, remove events to avoid answering twice			//report success			if(mGameCounters[pCounterId].number == G4Data.gameGoal.currentGoal){				//Estas dos lineas fueron colocas acá para que desaparezcan al mismo tiempo las respuestas y los distractors				if (mBubbleId.Name.Text.indexOf("ChangePlus") == -1){					removeDistractorCharacter();					setOverallAnimation(mGameCharacters, "smile");					removeCounters(pCounterId);					addCounterEvents(false);					reportSuccess();				}				else {					//El caso de la bubble ChangePlus					if (firstQuestion) {						//Estas tres lineas son para poner un mensaje de exito y su correspondiente sonido.						lookXMoreMessage(null);						if(G4Data.lvl_Indoors)						{							timerMoveFirstGroup = new Timer(1500,1);							timerMoveFirstGroup.start();							timerMoveFirstGroup.addEventListener(TimerEvent.TIMER_COMPLETE, moveFirstGroup, false, 0 , true);						}													removeCounters(pCounterId); 											}					else {						//Este es el caso en el que se ha respondido correctamente la segunda pregunta						removeDistractorCharacter();						setOverallAnimation(mGameCharacters, "smile");						removeCounters(pCounterId);						addCounterEvents(false);						reportSuccess();					}				}			}			//if its not correct			else {				mGameCounters[pCounterId].visible = false;				reportFailure();			}		}		private function moveFirstGroup(e : Event)		{			timerMoveFirstGroup.removeEventListener(TimerEvent.TIMER_COMPLETE, moveFirstGroup);			mLookMoreMessage.removeEventListener(Game4Message.MESSAGE_SOUND_PLAYED, moveFirstGroup);			movingFirsGroup = true;			moveCharactersToHouse(0, true);					}		private function initSecondQuestion(e : Event){									movingFirsGroup = false;			firstQuestion = false;			removeCounters();									//El false es porque se trata del segundo grupo de characters			putGroupChangePlus(false);			suitCharacters(mGameCharacters, changePlusScheme[0]);//Coloco solo los nuevos characters agregados: los del segundo grupo			(mData as Game4Data).updateCurrentGoal(changePlusScheme[0] + changePlusScheme[1]);			//setupCounters(changePlusScheme[0] + changePlusScheme[1]);			//disableCounters(changePlusScheme[0] + changePlusScheme[1]);			//disableCounters(changePlusScheme[1]);			//Con este timer, al cumplirse un cierto tiempo se invoca al método makeSecondQuestion			Util.debug("Game4.moveFirstGroup starting timer");			timerSecondQuestion.delay = 2500 + 400*changePlusScheme[1];			timerSecondQuestion.start();			//Se coloca el mensaje "Look X more monkeys/birds....."			timerLookMessage.delay = 1000;			timerLookMessage.start();			//poseIntermediateMessage();		}		//Este método mueve el segundo grupo de characters junto al primero y luego crea los nuevos counters. 		//Dichas cosas se realizan invocando los métodos correspondientes.		private function makeSecondQuestion(e : Event) {			//Con esta asignación, al terminar de arrivar todos los characters se realiza la segunda pregunta			secondQuestion = true;						if ((mData as Game4Data).lvl_Indoors){				moveCharactersToHouse(changePlusScheme[0],false);			}			else moveCharactersBesideFirstGroup();		}		//Este método coloca los characters del segundo grupo junto a los del primer grupo. 		private function moveCharactersBesideFirstGroup() {			//Si la primera rama izquierda esta llena entonces hay agregar los movimientos extras producidos por el jump cuando hay que bajar de rama para			//acomodar junto al primer grupo			if (changePlusScheme[0] > 5 && mPlayerKind == CharQual.MONKEY){				Util.debug("ENTRO AL SEGUNDO CASO");				disableCounters(changePlusScheme[1] * 2);			}			else {				Util.debug("ENTRO AL PRIMER CASO"); 				disableCounters(changePlusScheme[1]);			}			//La cantidad de characters del segundo grupo.			var cantSecondGroup : uint = changePlusScheme[1];			var newPosition : Point2D;			var nextPosition : Point2D;			var posSecondBranch : uint = 0;			for (var i = 0; i < cantSecondGroup; i++) {				if ((changePlusScheme[0] + i) < 5){					//mover el character a la posicion en la misma primera rama, la rama cero					newPosition = platforms.coordsToPixels(new Point2D(changePlusScheme[0] + i, 0));					//Aca se lleva a cabo el movimiento					moveGCTo(changePlusScheme[0] + i, newPosition, false);					mGameCharacters[changePlusScheme[0] + i].animate("moveLeft");				}				else {					//La posición en la rama de abajo					newPosition = platforms.coordsToPixels(new Point2D(mGameCharacters[changePlusScheme[0] + i].Coord.x, 1));					//La posición junto al último character del primer grupo					nextPosition = platforms.coordsToPixels(new Point2D((changePlusScheme[0] % 5) + posSecondBranch, 1));										Util.debug("moving to new position " + newPosition);					if (mPlayerKind == CharQual.MONKEY){						//Aca se lleva a cabo el movimiento						moveGCTo(changePlusScheme[0] + i, newPosition, false, true,nextPosition);						mGameCharacters[changePlusScheme[0] + i].animate("jumpDown");					}					else {						moveGCTo(changePlusScheme[0] + i, nextPosition, false, false, null);						mGameCharacters[changePlusScheme[0] + i].animate("moveLeft");					}					posSecondBranch++;				}			}		}		//Muestra y reproduce el sonido correspondiente al mensaje intermedio en la bubble ChangePlus: "Look X more..."		private function lookXMoreMessage(e : Event) {			if(mLookMoreMessage)				mLookMoreMessage.removeEventListener(Game4Message.MESSAGE_SOUND_PLAYED, initSecondQuestion);							mLookMoreMessage = new Game4Message(G4Data.Language.Text);			var numCharacters : int = firstQuestion ? changePlusScheme[0] : changePlusScheme[1];			mLookMoreMessage.makeIntermediateMessage(firstQuestion, numCharacters, CharQual.SPECIES_NAMES[mPlayerKind] + "s", G4Data.lvl_Indoors);							mLookMoreMessage.writeMessageTo(tQuestionText);			mLookMoreMessage.playSound();									if(firstQuestion && !G4Data.lvl_Indoors)				mLookMoreMessage.addEventListener(Game4Message.MESSAGE_SOUND_PLAYED, initSecondQuestion);		}						//$Hide counters that are not the solution		private function removeCounters(pGoalId = -1){			if(!mGameCounters)				return;			for(var i: Number = 0; i < mGameCounters.length; i++){				if (i != pGoalId) 					Util.removeChild(mGameCounters[i]);				else {					//Se deshabilita el counter que vino como parametro					EventManager.removeEvent(mGameCounters[i], MouseEvent.CLICK);					mGameCounters[i].buttonMode = false;					if(GameLib.driver) CursorManager.removeOverEvents(mGameCounters[i]);				}			}		}					//$Pose question		//generate sound with the question		//fill text field with the text for the question		private function poseQuestion (event: Event = null) {			tStatusText.text = "";			mQuestionMessage = new Game4Message(G4Data.Language.Text, Game4Message.MSG_QUESTION);			if (mBubbleId.Name.Text.indexOf("ChangePlus") != -1)				 mQuestionMessage.makeCountQuestion(G4Data.gameGoal , CharQual.SPECIES_NAMES[mPlayerKind] + "s", subquality, 0, cantExecutions, !firstQuestion, G4Data.lvl_Indoors);			else mQuestionMessage.makeCountQuestion(G4Data.gameGoal , CharQual.SPECIES_NAMES[mPlayerKind] + "s",subquality, 0, cantExecutions);			mQuestionMessage.writeMessageTo(tQuestionText);			mQuestionMessage.playSound();		}		//Repeat question		public function repeatQuestion( e : Event = null)		{			if(mStatusMessage)	  			mStatusMessage.removeEventListener(Game4Message.MESSAGE_SOUND_PLAYED, repeatQuestion);	  						poseQuestion();		}		//*Report round success		private function reportSuccess() {			//*When the user gets it right, we stop the counter and record movement			G4Data.stopTaskTimer();			G4Data.recordMove(GameLib.TASK_SUCCESS)						if(changePlusScheme)			{				G4Data.taskXML.@group1 = changePlusScheme[0];				G4Data.taskXML.@group2 = changePlusScheme[1];			}						//*stop any question as well			if(mQuestionMessage)				mQuestionMessage.stopSound();			if(mStatusMessage){				mStatusMessage.stopSound();				mStatusMessage.removeEventListener(Game4Message.MESSAGE_SOUND_PLAYED, poseQuestion);			}			mStatusMessage = new Game4Message(G4Data.Language.Text, Game4Message.MSG_SUCCESS);			mStatusMessage.writeMessageTo(tStatusText);			mStatusMessage.playSound();			mStatusMessage.addEventListener(Game4Message.MESSAGE_SOUND_PLAYED, isTaskFinished, false, 0 , true);		}		//*report round failure		private function reportFailure() {			//Carlos			G4Data.moveFailedXML.@groupFailed = firstQuestion ? 1 : 2;			Util.debug("group failed " + G4Data.moveFailedXML.@groupFailed);						G4Data.recordMove(GameLib.TASK_FAILURE, G4Data.gameGoal.currentGoal);			if(mQuestionMessage)				mQuestionMessage.stopSound();			if(mStatusMessage)			{				mStatusMessage.stopSound();				mStatusMessage.removeEventListener(Game4Message.MESSAGE_SOUND_PLAYED, poseQuestion);			}						mStatusMessage = Game4Message.generateFailureSound(G4Data.Language.Text, G4Data.gameGoal);			mStatusMessage.writeMessageTo(tStatusText);			mStatusMessage.playSound();			//Util.debug(G4Data.gameGoal.attemptCounter)			//Util.debug("report failure attempt " + G4Data.gameGoal.attemptCounter);			if(G4Data.gameGoal.attemptCounter < 2 || Math.random() > 0.5)				mStatusMessage.addEventListener(Game4Message.MESSAGE_SOUND_PLAYED, poseQuestion, false, 0 , true);		}		//*Check if total tasks have been done		public function isTaskFinished(e : Event){			if(G4Data.gameGoal.taskCounter >= G4Data.gameGoal.totalTasks)				 playEndAnimation();			else startRound();		}		//Función para que los characters caminen desde su posición actual hasta afuera del escenario (DEPRECATED)		private function playExitAnimation(characters : Array) {			var finalPosition : Point2D;			for(var i=0; i < characters.length; i++){				//En funcion de la posicion en la grilla en la que debe ser colocado el monkey,				//se crea una nueva posicion desde la cual el monkey se desplace hasta su posicion final				if (characters[i].Coord.x < 5){					finalPosition = platforms.coordsToPixels(new Point2D(0,characters[i].Coord.y));					finalPosition.x = finalPosition.x - 500;				}				else {					finalPosition = platforms.coordsToPixels(new Point2D(9,characters[i].Coord.y));					finalPosition.x = finalPosition.x + 500;				}				//Aca se lleva a cabo el movimiento				moveGCTo(i, finalPosition);				characters[i].scaleX = -1;				characters[i].animate("moveLeft");			}		}		//Esta función setea una animation para un conjunto de characters		public function setOverallAnimation(characters : Array,animation : String) {			for (var i = 0; i < characters.length; i++) {				characters[i].animate(animation);			}		}		//$play end animation		public function playEndAnimation(){			endAnimation_mc = Util.createMc(mPlayerWord + "EndAnimation" + Util.getRandBtw(1,CharQual.NUM_ANIMATIONS[CharQual.END][mPlayerKind]));			endAnimation_mc.y = 200;			addChild(endAnimation_mc);			endAnimation_mc.gotoAndPlay(1);			addEventListener(Event.ENTER_FRAME, onAnimationProgress, false, 0 , true);			tQuestionText.visible = false;			tStatusText.visible = false;						addChild(tInteractionPanel);			for(var i=0; i < mGameCounters.length; i++)				addChild(mGameCounters[i]);			setOverallAnimation(mGameCharacters, "teasing" + Util.getRandBtw(1,CharQual.NUM_ANIMATIONS[CharQual.TEASING][mPlayerKind]));//Una tesing animation random: teasing1 or teasing2 or teasing3					}				//$Listener function that tells whether the end animation is done		public function onAnimationProgress (e:Event){			if(endAnimation_mc.currentLabel == "ANIMATION_DONE"){				this.removeEventListener(Event.ENTER_FRAME, onAnimationProgress);				this.dispatchEvent(new Event(GameLib.BUBBLE_FINISHED));				var returnToDriverTimer : Timer = new Timer(2 , 1);				returnToDriverTimer.start();				returnToDriverTimer.addEventListener(TimerEvent.TIMER, returnToDriver, false, 0 , true);			}						//Justo antes que el pajaro salte, los pajaros vuelan antes que el gato salte			if(G4Data.lvl_Indoors)			{							if(endAnimation_mc.currentFrame == 10)				{					for (var i = 0; i < mGameCharacters.length; i++) {											if(mGameCharacters[i].Coord.y > 0)						{							mGameCharacters[i].Coord.x = mGameCharacters[i].Coord.x + 5;							mGameCharacters[i].Coord.y = 0;						}												this.moveGCTo(i, platforms.coordsToPixels(mGameCharacters[i].Coord));						mGameCharacters[i].animate("moveLeft");						mGameCharacters[i].visible = true;									}				}			}						//Justo antes que el pajaro salte, los pajaros vuelan antes que el gato salte			else if(mPlayerKind == CharQual.BIRD && endAnimation_mc.currentFrame == 60)			{				for (var i = 0; i < mGameCharacters.length; i++) {										mGameCharacters[i].moveAway();				}			}					}		//%Move GC to other point of the screen		private function moveGCTo(pGC_Id : int, pMoveToPoint : Point2D, hideCharacter : Boolean = false, isJump : Boolean = false, nextPosition : Point2D = null) {			mGCMove[pGC_Id] = mGameCharacters[pGC_Id].gotoDestination(pMoveToPoint, 1.0, -1, isJump);			EventManager.addEvent(mGCMove[pGC_Id], GCMovement.GC_MOTION_FINISH, arriveAtDest, pGC_Id, hideCharacter,nextPosition);		}		//%Event to alert that GC has arrived at destination		private function arriveAtDest(event: Event, pGC_Id: Number, hideCharacter : Boolean = false, nextPosition : Point2D = null) {			//Se va descontando la cantidad de characters que restan moverse, es decir que todavia no han llegado a destino.			Util.debug("CANTIDAD DE MOVIMIENTOS: " + cantCharactersToMove);			Util.debug("arriveAt pajaro id: " + pGC_Id + " " + mGameCharacters[pGC_Id].x + " " + mGameCharacters[pGC_Id].y);					//var exactDest : Point2D =  platforms.coordsToPixels(mGameCharacters[pGC_Id].Coord);			//mGameCharacters[pGC_Id].x = exactDest.x;			//mGameCharacters[pGC_Id].y = exactDest.y;						Util.debug("arriveAt pajaro id: " + pGC_Id + " " + mGameCharacters[pGC_Id].x + " " + mGameCharacters[pGC_Id].y);						cantCharactersToMove--;			if (cantCharactersToMove == 0){				Util.debug("ESTOY ACTIVANDO DE NUEVO LOS COUNTERS");				addCounterEvents(true);								if (movingFirsGroup) {					Util.debug("Llamando a initSecondQuestion");					initSecondQuestion(null);				}												if(firstQuestion && !movingFirsGroup )					poseQuestion();									if (secondQuestion){					setupCounters(changePlusScheme[0] + changePlusScheme[1]);					poseQuestion();				}			}			EventManager.removeEvent(mGCMove[pGC_Id], GCMovement.GC_MOTION_FINISH);			//If its not the last time im moving birds/monkeys			if (endAnimation_mc == null) {				if (hideCharacter) {					//Util.removeChild(mGameCharacters[pGC_Id]);					mGameCharacters[pGC_Id].visible = false;				}				else{					//if character is bird, need to play landing animation					if(mPlayerKind == CharQual.BIRD)						 mGameCharacters[pGC_Id].animate("Land");					else mGameCharacters[pGC_Id].animate("idle", CharQual.NUM_ANIMATIONS[CharQual.IDLE][mPlayerKind]);				}			}			else			{				Util.debug("moving gc to screen");				if(mPlayerKind == CharQual.MONKEY)					mGameCharacters[pGC_Id].animate("teasing", 3);				else					mGameCharacters[pGC_Id].animate("smile");			}			if (nextPosition != null) {				//Aca se lleva a cabo el movimiento				moveGCTo(pGC_Id, nextPosition, (mData as Game4Data).lvl_Indoors);				mGameCharacters[pGC_Id].animate("moveLeft");			}		}		private function moveAllGCsToScreen(){			var gc : Game4Player;			for(var i =0; i < mGameCharacters.length; i++){				//Util.debug("moving gc to screen");				mGameCharacters[i].animate("crawlLeft");				var tile : Point2D = platforms.coordsToPixels(mGameCharacters[i].Tile);				Util.debug("moving monkey in " + mGameCharacters[i].Tile + " to " + tile);				moveGCTo(i, tile);			}		}		private function movedToScreen(event: Event, pGC_Id: Number){			//GCsOnScreen++;			if(Util.getRandBtw(0,1))				mGameCharacters[pGC_Id].animate("idle");			mGCMove[pGC_Id].removeEventListener(GCMovement.GC_MOTION_FINISH, arriveAtDest);		}		private function jumpGC(pGC_Id : int, pDirection : Point2D){			var oldTile : Point2D = mGameCharacters[pGC_Id].Tile;			var j = oldTile.y + pDirection.y;			var i = oldTile.x + pDirection.x;			if(board[i][j] != null)				mGCMove[pGC_Id] = mGameCharacters[pGC_Id].gotoDestination(board[i][j]);			mGameCharacters[pGC_Id].animate("jump");		}		//*stop all audio in game except music		public function stopMessages(){			if(timer)			{					timer.stop();				timer.removeEventListener(TimerEvent.TIMER_COMPLETE, removeGameCharacters);			}				//Se usan para el caso de la bubble ChangePlus. Para retrasar la ejecución de la segunda pregunta			if(timerSecondQuestion)			{				timerSecondQuestion.stop();				timerSecondQuestion.removeEventListener(TimerEvent.TIMER_COMPLETE, makeSecondQuestion);						}			//Se usan para el caso de la bubble ChangePlus. Para retrasar la ejecución de la pregunta intermedia (poseIntermediateMessage)			if(timerLookMessage)			{				timerLookMessage.stop();				timerLookMessage.addEventListener(TimerEvent.TIMER_COMPLETE, lookXMoreMessage);						}						if(mLookMoreMessage)			{				mLookMoreMessage.removeEventListener(Game4Message.MESSAGE_SOUND_PLAYED, initSecondQuestion);				mLookMoreMessage.stopSound();			}						if(mStatusMessage)			{				mStatusMessage.removeEventListener(Game4Message.MESSAGE_SOUND_PLAYED, poseQuestion);				mStatusMessage.stopSound();			}							if(mQuestionMessage)				mQuestionMessage.stopSound();		}		//*cleans all events and stop messages		public override function onRemove (e : Event) 		{						if(mGCMove)			{				Util.debug("removing events mGCMove" + mGCMove.length);				for(var i=0; i< mGCMove.length; i++)					EventManager.removeEvent(mGCMove[i], GCMovement.GC_MOTION_FINISH);			}							removeEventListener (Event.REMOVED_FROM_STAGE, onRemove);			stopMessages();			if(mMusicChannel)				mMusicChannel.stop();		}		//* after bubble is finished, 		public function returnToDriver(e : Event){			//Util.debug("return to driver game3",this);			G4Data.dispatchEvent(new Event(GameLib.RETURN_TO_DRIVER));		}		//Este metodo deshabilita los counters.		private function disableCounters (cantCharacters : uint) {			//Seteo la cantidad de characters que van a moverse			cantCharactersToMove = cantCharacters;			//Se desactivan los counters para evitar problemas con las animaciones			addCounterEvents(false);		}		public function get Name()		: EGame		{ return EGame.G4;}		public override function get Data()  		{ return (mData as Game4Data)};		public function get G4Data() : Game4Data	{ return (mData as Game4Data)}	}}